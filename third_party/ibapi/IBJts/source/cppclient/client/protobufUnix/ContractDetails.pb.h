// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ContractDetails.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ContractDetails_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ContractDetails_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "IneligibilityReason.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ContractDetails_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ContractDetails_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ContractDetails_2eproto;
namespace protobuf {
class ContractDetails;
struct ContractDetailsDefaultTypeInternal;
extern ContractDetailsDefaultTypeInternal _ContractDetails_default_instance_;
class ContractDetails_SecIdListEntry_DoNotUse;
struct ContractDetails_SecIdListEntry_DoNotUseDefaultTypeInternal;
extern ContractDetails_SecIdListEntry_DoNotUseDefaultTypeInternal _ContractDetails_SecIdListEntry_DoNotUse_default_instance_;
}  // namespace protobuf
PROTOBUF_NAMESPACE_OPEN
template<> ::protobuf::ContractDetails* Arena::CreateMaybeMessage<::protobuf::ContractDetails>(Arena*);
template<> ::protobuf::ContractDetails_SecIdListEntry_DoNotUse* Arena::CreateMaybeMessage<::protobuf::ContractDetails_SecIdListEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protobuf {

// ===================================================================

class ContractDetails_SecIdListEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContractDetails_SecIdListEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ContractDetails_SecIdListEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ContractDetails_SecIdListEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ContractDetails_SecIdListEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ContractDetails_SecIdListEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ContractDetails_SecIdListEntry_DoNotUse& other);
  static const ContractDetails_SecIdListEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ContractDetails_SecIdListEntry_DoNotUse*>(&_ContractDetails_SecIdListEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.ContractDetails.SecIdListEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protobuf.ContractDetails.SecIdListEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ContractDetails_2eproto;
};

// -------------------------------------------------------------------

class ContractDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuf.ContractDetails) */ {
 public:
  inline ContractDetails() : ContractDetails(nullptr) {}
  ~ContractDetails() override;
  explicit PROTOBUF_CONSTEXPR ContractDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractDetails(const ContractDetails& from);
  ContractDetails(ContractDetails&& from) noexcept
    : ContractDetails() {
    *this = ::std::move(from);
  }

  inline ContractDetails& operator=(const ContractDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractDetails& operator=(ContractDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractDetails* internal_default_instance() {
    return reinterpret_cast<const ContractDetails*>(
               &_ContractDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContractDetails& a, ContractDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractDetails& from) {
    ContractDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuf.ContractDetails";
  }
  protected:
  explicit ContractDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecIdListFieldNumber = 17,
    kIneligibilityReasonListFieldNumber = 58,
    kMarketNameFieldNumber = 1,
    kMinTickFieldNumber = 2,
    kOrderTypesFieldNumber = 3,
    kValidExchangesFieldNumber = 4,
    kLongNameFieldNumber = 7,
    kContractMonthFieldNumber = 8,
    kIndustryFieldNumber = 9,
    kCategoryFieldNumber = 10,
    kSubcategoryFieldNumber = 11,
    kTimeZoneIdFieldNumber = 12,
    kTradingHoursFieldNumber = 13,
    kLiquidHoursFieldNumber = 14,
    kEvRuleFieldNumber = 15,
    kUnderSymbolFieldNumber = 19,
    kUnderSecTypeFieldNumber = 20,
    kMarketRuleIdsFieldNumber = 21,
    kRealExpirationDateFieldNumber = 22,
    kStockTypeFieldNumber = 23,
    kMinSizeFieldNumber = 24,
    kSizeIncrementFieldNumber = 25,
    kSuggestedSizeIncrementFieldNumber = 26,
    kFundNameFieldNumber = 27,
    kFundFamilyFieldNumber = 28,
    kFundTypeFieldNumber = 29,
    kFundFrontLoadFieldNumber = 30,
    kFundBackLoadFieldNumber = 31,
    kFundBackLoadTimeIntervalFieldNumber = 32,
    kFundManagementFeeFieldNumber = 33,
    kFundNotifyAmountFieldNumber = 37,
    kFundMinimumInitialPurchaseFieldNumber = 38,
    kFundMinimumSubsequentPurchaseFieldNumber = 39,
    kFundBlueSkyStatesFieldNumber = 40,
    kFundBlueSkyTerritoriesFieldNumber = 41,
    kFundDistributionPolicyIndicatorFieldNumber = 42,
    kFundAssetTypeFieldNumber = 43,
    kCusipFieldNumber = 44,
    kIssueDateFieldNumber = 45,
    kRatingsFieldNumber = 46,
    kBondTypeFieldNumber = 47,
    kCouponTypeFieldNumber = 49,
    kDescAppendFieldNumber = 53,
    kNextOptionDateFieldNumber = 54,
    kNextOptionTypeFieldNumber = 55,
    kBondNotesFieldNumber = 57,
    kEventContract1FieldNumber = 59,
    kEventContractDescription1FieldNumber = 60,
    kEventContractDescription2FieldNumber = 61,
    kMinAlgoSizeFieldNumber = 62,
    kPriceMagnifierFieldNumber = 5,
    kUnderConIdFieldNumber = 6,
    kEvMultiplierFieldNumber = 16,
    kAggGroupFieldNumber = 18,
    kFundClosedFieldNumber = 34,
    kFundClosedForNewInvestorsFieldNumber = 35,
    kFundClosedForNewMoneyFieldNumber = 36,
    kConvertibleFieldNumber = 50,
    kCouponFieldNumber = 48,
    kCallableFieldNumber = 51,
    kPuttableFieldNumber = 52,
    kNextOptionPartialFieldNumber = 56,
  };
  // map<string, string> secIdList = 17;
  int secidlist_size() const;
  private:
  int _internal_secidlist_size() const;
  public:
  void clear_secidlist();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secidlist() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secidlist();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secidlist() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secidlist();

  // repeated .protobuf.IneligibilityReason ineligibilityReasonList = 58;
  int ineligibilityreasonlist_size() const;
  private:
  int _internal_ineligibilityreasonlist_size() const;
  public:
  void clear_ineligibilityreasonlist();
  ::protobuf::IneligibilityReason* mutable_ineligibilityreasonlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::IneligibilityReason >*
      mutable_ineligibilityreasonlist();
  private:
  const ::protobuf::IneligibilityReason& _internal_ineligibilityreasonlist(int index) const;
  ::protobuf::IneligibilityReason* _internal_add_ineligibilityreasonlist();
  public:
  const ::protobuf::IneligibilityReason& ineligibilityreasonlist(int index) const;
  ::protobuf::IneligibilityReason* add_ineligibilityreasonlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::IneligibilityReason >&
      ineligibilityreasonlist() const;

  // optional string marketName = 1;
  bool has_marketname() const;
  private:
  bool _internal_has_marketname() const;
  public:
  void clear_marketname();
  const std::string& marketname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_marketname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_marketname();
  PROTOBUF_NODISCARD std::string* release_marketname();
  void set_allocated_marketname(std::string* marketname);
  private:
  const std::string& _internal_marketname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketname(const std::string& value);
  std::string* _internal_mutable_marketname();
  public:

  // optional string minTick = 2;
  bool has_mintick() const;
  private:
  bool _internal_has_mintick() const;
  public:
  void clear_mintick();
  const std::string& mintick() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mintick(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mintick();
  PROTOBUF_NODISCARD std::string* release_mintick();
  void set_allocated_mintick(std::string* mintick);
  private:
  const std::string& _internal_mintick() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mintick(const std::string& value);
  std::string* _internal_mutable_mintick();
  public:

  // optional string orderTypes = 3;
  bool has_ordertypes() const;
  private:
  bool _internal_has_ordertypes() const;
  public:
  void clear_ordertypes();
  const std::string& ordertypes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ordertypes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ordertypes();
  PROTOBUF_NODISCARD std::string* release_ordertypes();
  void set_allocated_ordertypes(std::string* ordertypes);
  private:
  const std::string& _internal_ordertypes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordertypes(const std::string& value);
  std::string* _internal_mutable_ordertypes();
  public:

  // optional string validExchanges = 4;
  bool has_validexchanges() const;
  private:
  bool _internal_has_validexchanges() const;
  public:
  void clear_validexchanges();
  const std::string& validexchanges() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_validexchanges(ArgT0&& arg0, ArgT... args);
  std::string* mutable_validexchanges();
  PROTOBUF_NODISCARD std::string* release_validexchanges();
  void set_allocated_validexchanges(std::string* validexchanges);
  private:
  const std::string& _internal_validexchanges() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validexchanges(const std::string& value);
  std::string* _internal_mutable_validexchanges();
  public:

  // optional string longName = 7;
  bool has_longname() const;
  private:
  bool _internal_has_longname() const;
  public:
  void clear_longname();
  const std::string& longname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_longname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_longname();
  PROTOBUF_NODISCARD std::string* release_longname();
  void set_allocated_longname(std::string* longname);
  private:
  const std::string& _internal_longname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_longname(const std::string& value);
  std::string* _internal_mutable_longname();
  public:

  // optional string contractMonth = 8;
  bool has_contractmonth() const;
  private:
  bool _internal_has_contractmonth() const;
  public:
  void clear_contractmonth();
  const std::string& contractmonth() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contractmonth(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contractmonth();
  PROTOBUF_NODISCARD std::string* release_contractmonth();
  void set_allocated_contractmonth(std::string* contractmonth);
  private:
  const std::string& _internal_contractmonth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractmonth(const std::string& value);
  std::string* _internal_mutable_contractmonth();
  public:

  // optional string industry = 9;
  bool has_industry() const;
  private:
  bool _internal_has_industry() const;
  public:
  void clear_industry();
  const std::string& industry() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_industry(ArgT0&& arg0, ArgT... args);
  std::string* mutable_industry();
  PROTOBUF_NODISCARD std::string* release_industry();
  void set_allocated_industry(std::string* industry);
  private:
  const std::string& _internal_industry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_industry(const std::string& value);
  std::string* _internal_mutable_industry();
  public:

  // optional string category = 10;
  bool has_category() const;
  private:
  bool _internal_has_category() const;
  public:
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // optional string subcategory = 11;
  bool has_subcategory() const;
  private:
  bool _internal_has_subcategory() const;
  public:
  void clear_subcategory();
  const std::string& subcategory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subcategory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subcategory();
  PROTOBUF_NODISCARD std::string* release_subcategory();
  void set_allocated_subcategory(std::string* subcategory);
  private:
  const std::string& _internal_subcategory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subcategory(const std::string& value);
  std::string* _internal_mutable_subcategory();
  public:

  // optional string timeZoneId = 12;
  bool has_timezoneid() const;
  private:
  bool _internal_has_timezoneid() const;
  public:
  void clear_timezoneid();
  const std::string& timezoneid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezoneid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezoneid();
  PROTOBUF_NODISCARD std::string* release_timezoneid();
  void set_allocated_timezoneid(std::string* timezoneid);
  private:
  const std::string& _internal_timezoneid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezoneid(const std::string& value);
  std::string* _internal_mutable_timezoneid();
  public:

  // optional string tradingHours = 13;
  bool has_tradinghours() const;
  private:
  bool _internal_has_tradinghours() const;
  public:
  void clear_tradinghours();
  const std::string& tradinghours() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tradinghours(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tradinghours();
  PROTOBUF_NODISCARD std::string* release_tradinghours();
  void set_allocated_tradinghours(std::string* tradinghours);
  private:
  const std::string& _internal_tradinghours() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tradinghours(const std::string& value);
  std::string* _internal_mutable_tradinghours();
  public:

  // optional string liquidHours = 14;
  bool has_liquidhours() const;
  private:
  bool _internal_has_liquidhours() const;
  public:
  void clear_liquidhours();
  const std::string& liquidhours() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_liquidhours(ArgT0&& arg0, ArgT... args);
  std::string* mutable_liquidhours();
  PROTOBUF_NODISCARD std::string* release_liquidhours();
  void set_allocated_liquidhours(std::string* liquidhours);
  private:
  const std::string& _internal_liquidhours() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liquidhours(const std::string& value);
  std::string* _internal_mutable_liquidhours();
  public:

  // optional string evRule = 15;
  bool has_evrule() const;
  private:
  bool _internal_has_evrule() const;
  public:
  void clear_evrule();
  const std::string& evrule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_evrule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_evrule();
  PROTOBUF_NODISCARD std::string* release_evrule();
  void set_allocated_evrule(std::string* evrule);
  private:
  const std::string& _internal_evrule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_evrule(const std::string& value);
  std::string* _internal_mutable_evrule();
  public:

  // optional string underSymbol = 19;
  bool has_undersymbol() const;
  private:
  bool _internal_has_undersymbol() const;
  public:
  void clear_undersymbol();
  const std::string& undersymbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_undersymbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_undersymbol();
  PROTOBUF_NODISCARD std::string* release_undersymbol();
  void set_allocated_undersymbol(std::string* undersymbol);
  private:
  const std::string& _internal_undersymbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_undersymbol(const std::string& value);
  std::string* _internal_mutable_undersymbol();
  public:

  // optional string underSecType = 20;
  bool has_undersectype() const;
  private:
  bool _internal_has_undersectype() const;
  public:
  void clear_undersectype();
  const std::string& undersectype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_undersectype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_undersectype();
  PROTOBUF_NODISCARD std::string* release_undersectype();
  void set_allocated_undersectype(std::string* undersectype);
  private:
  const std::string& _internal_undersectype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_undersectype(const std::string& value);
  std::string* _internal_mutable_undersectype();
  public:

  // optional string marketRuleIds = 21;
  bool has_marketruleids() const;
  private:
  bool _internal_has_marketruleids() const;
  public:
  void clear_marketruleids();
  const std::string& marketruleids() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_marketruleids(ArgT0&& arg0, ArgT... args);
  std::string* mutable_marketruleids();
  PROTOBUF_NODISCARD std::string* release_marketruleids();
  void set_allocated_marketruleids(std::string* marketruleids);
  private:
  const std::string& _internal_marketruleids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketruleids(const std::string& value);
  std::string* _internal_mutable_marketruleids();
  public:

  // optional string realExpirationDate = 22;
  bool has_realexpirationdate() const;
  private:
  bool _internal_has_realexpirationdate() const;
  public:
  void clear_realexpirationdate();
  const std::string& realexpirationdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realexpirationdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realexpirationdate();
  PROTOBUF_NODISCARD std::string* release_realexpirationdate();
  void set_allocated_realexpirationdate(std::string* realexpirationdate);
  private:
  const std::string& _internal_realexpirationdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realexpirationdate(const std::string& value);
  std::string* _internal_mutable_realexpirationdate();
  public:

  // optional string stockType = 23;
  bool has_stocktype() const;
  private:
  bool _internal_has_stocktype() const;
  public:
  void clear_stocktype();
  const std::string& stocktype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stocktype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stocktype();
  PROTOBUF_NODISCARD std::string* release_stocktype();
  void set_allocated_stocktype(std::string* stocktype);
  private:
  const std::string& _internal_stocktype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stocktype(const std::string& value);
  std::string* _internal_mutable_stocktype();
  public:

  // optional string minSize = 24;
  bool has_minsize() const;
  private:
  bool _internal_has_minsize() const;
  public:
  void clear_minsize();
  const std::string& minsize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minsize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minsize();
  PROTOBUF_NODISCARD std::string* release_minsize();
  void set_allocated_minsize(std::string* minsize);
  private:
  const std::string& _internal_minsize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minsize(const std::string& value);
  std::string* _internal_mutable_minsize();
  public:

  // optional string sizeIncrement = 25;
  bool has_sizeincrement() const;
  private:
  bool _internal_has_sizeincrement() const;
  public:
  void clear_sizeincrement();
  const std::string& sizeincrement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sizeincrement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sizeincrement();
  PROTOBUF_NODISCARD std::string* release_sizeincrement();
  void set_allocated_sizeincrement(std::string* sizeincrement);
  private:
  const std::string& _internal_sizeincrement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sizeincrement(const std::string& value);
  std::string* _internal_mutable_sizeincrement();
  public:

  // optional string suggestedSizeIncrement = 26;
  bool has_suggestedsizeincrement() const;
  private:
  bool _internal_has_suggestedsizeincrement() const;
  public:
  void clear_suggestedsizeincrement();
  const std::string& suggestedsizeincrement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suggestedsizeincrement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suggestedsizeincrement();
  PROTOBUF_NODISCARD std::string* release_suggestedsizeincrement();
  void set_allocated_suggestedsizeincrement(std::string* suggestedsizeincrement);
  private:
  const std::string& _internal_suggestedsizeincrement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suggestedsizeincrement(const std::string& value);
  std::string* _internal_mutable_suggestedsizeincrement();
  public:

  // optional string fundName = 27;
  bool has_fundname() const;
  private:
  bool _internal_has_fundname() const;
  public:
  void clear_fundname();
  const std::string& fundname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundname();
  PROTOBUF_NODISCARD std::string* release_fundname();
  void set_allocated_fundname(std::string* fundname);
  private:
  const std::string& _internal_fundname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundname(const std::string& value);
  std::string* _internal_mutable_fundname();
  public:

  // optional string fundFamily = 28;
  bool has_fundfamily() const;
  private:
  bool _internal_has_fundfamily() const;
  public:
  void clear_fundfamily();
  const std::string& fundfamily() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundfamily(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundfamily();
  PROTOBUF_NODISCARD std::string* release_fundfamily();
  void set_allocated_fundfamily(std::string* fundfamily);
  private:
  const std::string& _internal_fundfamily() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundfamily(const std::string& value);
  std::string* _internal_mutable_fundfamily();
  public:

  // optional string fundType = 29;
  bool has_fundtype() const;
  private:
  bool _internal_has_fundtype() const;
  public:
  void clear_fundtype();
  const std::string& fundtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundtype();
  PROTOBUF_NODISCARD std::string* release_fundtype();
  void set_allocated_fundtype(std::string* fundtype);
  private:
  const std::string& _internal_fundtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundtype(const std::string& value);
  std::string* _internal_mutable_fundtype();
  public:

  // optional string fundFrontLoad = 30;
  bool has_fundfrontload() const;
  private:
  bool _internal_has_fundfrontload() const;
  public:
  void clear_fundfrontload();
  const std::string& fundfrontload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundfrontload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundfrontload();
  PROTOBUF_NODISCARD std::string* release_fundfrontload();
  void set_allocated_fundfrontload(std::string* fundfrontload);
  private:
  const std::string& _internal_fundfrontload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundfrontload(const std::string& value);
  std::string* _internal_mutable_fundfrontload();
  public:

  // optional string fundBackLoad = 31;
  bool has_fundbackload() const;
  private:
  bool _internal_has_fundbackload() const;
  public:
  void clear_fundbackload();
  const std::string& fundbackload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundbackload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundbackload();
  PROTOBUF_NODISCARD std::string* release_fundbackload();
  void set_allocated_fundbackload(std::string* fundbackload);
  private:
  const std::string& _internal_fundbackload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundbackload(const std::string& value);
  std::string* _internal_mutable_fundbackload();
  public:

  // optional string fundBackLoadTimeInterval = 32;
  bool has_fundbackloadtimeinterval() const;
  private:
  bool _internal_has_fundbackloadtimeinterval() const;
  public:
  void clear_fundbackloadtimeinterval();
  const std::string& fundbackloadtimeinterval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundbackloadtimeinterval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundbackloadtimeinterval();
  PROTOBUF_NODISCARD std::string* release_fundbackloadtimeinterval();
  void set_allocated_fundbackloadtimeinterval(std::string* fundbackloadtimeinterval);
  private:
  const std::string& _internal_fundbackloadtimeinterval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundbackloadtimeinterval(const std::string& value);
  std::string* _internal_mutable_fundbackloadtimeinterval();
  public:

  // optional string fundManagementFee = 33;
  bool has_fundmanagementfee() const;
  private:
  bool _internal_has_fundmanagementfee() const;
  public:
  void clear_fundmanagementfee();
  const std::string& fundmanagementfee() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundmanagementfee(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundmanagementfee();
  PROTOBUF_NODISCARD std::string* release_fundmanagementfee();
  void set_allocated_fundmanagementfee(std::string* fundmanagementfee);
  private:
  const std::string& _internal_fundmanagementfee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundmanagementfee(const std::string& value);
  std::string* _internal_mutable_fundmanagementfee();
  public:

  // optional string fundNotifyAmount = 37;
  bool has_fundnotifyamount() const;
  private:
  bool _internal_has_fundnotifyamount() const;
  public:
  void clear_fundnotifyamount();
  const std::string& fundnotifyamount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundnotifyamount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundnotifyamount();
  PROTOBUF_NODISCARD std::string* release_fundnotifyamount();
  void set_allocated_fundnotifyamount(std::string* fundnotifyamount);
  private:
  const std::string& _internal_fundnotifyamount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundnotifyamount(const std::string& value);
  std::string* _internal_mutable_fundnotifyamount();
  public:

  // optional string fundMinimumInitialPurchase = 38;
  bool has_fundminimuminitialpurchase() const;
  private:
  bool _internal_has_fundminimuminitialpurchase() const;
  public:
  void clear_fundminimuminitialpurchase();
  const std::string& fundminimuminitialpurchase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundminimuminitialpurchase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundminimuminitialpurchase();
  PROTOBUF_NODISCARD std::string* release_fundminimuminitialpurchase();
  void set_allocated_fundminimuminitialpurchase(std::string* fundminimuminitialpurchase);
  private:
  const std::string& _internal_fundminimuminitialpurchase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundminimuminitialpurchase(const std::string& value);
  std::string* _internal_mutable_fundminimuminitialpurchase();
  public:

  // optional string fundMinimumSubsequentPurchase = 39;
  bool has_fundminimumsubsequentpurchase() const;
  private:
  bool _internal_has_fundminimumsubsequentpurchase() const;
  public:
  void clear_fundminimumsubsequentpurchase();
  const std::string& fundminimumsubsequentpurchase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundminimumsubsequentpurchase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundminimumsubsequentpurchase();
  PROTOBUF_NODISCARD std::string* release_fundminimumsubsequentpurchase();
  void set_allocated_fundminimumsubsequentpurchase(std::string* fundminimumsubsequentpurchase);
  private:
  const std::string& _internal_fundminimumsubsequentpurchase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundminimumsubsequentpurchase(const std::string& value);
  std::string* _internal_mutable_fundminimumsubsequentpurchase();
  public:

  // optional string fundBlueSkyStates = 40;
  bool has_fundblueskystates() const;
  private:
  bool _internal_has_fundblueskystates() const;
  public:
  void clear_fundblueskystates();
  const std::string& fundblueskystates() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundblueskystates(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundblueskystates();
  PROTOBUF_NODISCARD std::string* release_fundblueskystates();
  void set_allocated_fundblueskystates(std::string* fundblueskystates);
  private:
  const std::string& _internal_fundblueskystates() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundblueskystates(const std::string& value);
  std::string* _internal_mutable_fundblueskystates();
  public:

  // optional string fundBlueSkyTerritories = 41;
  bool has_fundblueskyterritories() const;
  private:
  bool _internal_has_fundblueskyterritories() const;
  public:
  void clear_fundblueskyterritories();
  const std::string& fundblueskyterritories() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundblueskyterritories(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundblueskyterritories();
  PROTOBUF_NODISCARD std::string* release_fundblueskyterritories();
  void set_allocated_fundblueskyterritories(std::string* fundblueskyterritories);
  private:
  const std::string& _internal_fundblueskyterritories() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundblueskyterritories(const std::string& value);
  std::string* _internal_mutable_fundblueskyterritories();
  public:

  // optional string fundDistributionPolicyIndicator = 42;
  bool has_funddistributionpolicyindicator() const;
  private:
  bool _internal_has_funddistributionpolicyindicator() const;
  public:
  void clear_funddistributionpolicyindicator();
  const std::string& funddistributionpolicyindicator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funddistributionpolicyindicator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funddistributionpolicyindicator();
  PROTOBUF_NODISCARD std::string* release_funddistributionpolicyindicator();
  void set_allocated_funddistributionpolicyindicator(std::string* funddistributionpolicyindicator);
  private:
  const std::string& _internal_funddistributionpolicyindicator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funddistributionpolicyindicator(const std::string& value);
  std::string* _internal_mutable_funddistributionpolicyindicator();
  public:

  // optional string fundAssetType = 43;
  bool has_fundassettype() const;
  private:
  bool _internal_has_fundassettype() const;
  public:
  void clear_fundassettype();
  const std::string& fundassettype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fundassettype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fundassettype();
  PROTOBUF_NODISCARD std::string* release_fundassettype();
  void set_allocated_fundassettype(std::string* fundassettype);
  private:
  const std::string& _internal_fundassettype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fundassettype(const std::string& value);
  std::string* _internal_mutable_fundassettype();
  public:

  // optional string cusip = 44;
  bool has_cusip() const;
  private:
  bool _internal_has_cusip() const;
  public:
  void clear_cusip();
  const std::string& cusip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cusip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cusip();
  PROTOBUF_NODISCARD std::string* release_cusip();
  void set_allocated_cusip(std::string* cusip);
  private:
  const std::string& _internal_cusip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cusip(const std::string& value);
  std::string* _internal_mutable_cusip();
  public:

  // optional string issueDate = 45;
  bool has_issuedate() const;
  private:
  bool _internal_has_issuedate() const;
  public:
  void clear_issuedate();
  const std::string& issuedate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuedate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuedate();
  PROTOBUF_NODISCARD std::string* release_issuedate();
  void set_allocated_issuedate(std::string* issuedate);
  private:
  const std::string& _internal_issuedate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuedate(const std::string& value);
  std::string* _internal_mutable_issuedate();
  public:

  // optional string ratings = 46;
  bool has_ratings() const;
  private:
  bool _internal_has_ratings() const;
  public:
  void clear_ratings();
  const std::string& ratings() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ratings(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ratings();
  PROTOBUF_NODISCARD std::string* release_ratings();
  void set_allocated_ratings(std::string* ratings);
  private:
  const std::string& _internal_ratings() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ratings(const std::string& value);
  std::string* _internal_mutable_ratings();
  public:

  // optional string bondType = 47;
  bool has_bondtype() const;
  private:
  bool _internal_has_bondtype() const;
  public:
  void clear_bondtype();
  const std::string& bondtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bondtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bondtype();
  PROTOBUF_NODISCARD std::string* release_bondtype();
  void set_allocated_bondtype(std::string* bondtype);
  private:
  const std::string& _internal_bondtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bondtype(const std::string& value);
  std::string* _internal_mutable_bondtype();
  public:

  // optional string couponType = 49;
  bool has_coupontype() const;
  private:
  bool _internal_has_coupontype() const;
  public:
  void clear_coupontype();
  const std::string& coupontype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coupontype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coupontype();
  PROTOBUF_NODISCARD std::string* release_coupontype();
  void set_allocated_coupontype(std::string* coupontype);
  private:
  const std::string& _internal_coupontype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coupontype(const std::string& value);
  std::string* _internal_mutable_coupontype();
  public:

  // optional string descAppend = 53;
  bool has_descappend() const;
  private:
  bool _internal_has_descappend() const;
  public:
  void clear_descappend();
  const std::string& descappend() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_descappend(ArgT0&& arg0, ArgT... args);
  std::string* mutable_descappend();
  PROTOBUF_NODISCARD std::string* release_descappend();
  void set_allocated_descappend(std::string* descappend);
  private:
  const std::string& _internal_descappend() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_descappend(const std::string& value);
  std::string* _internal_mutable_descappend();
  public:

  // optional string nextOptionDate = 54;
  bool has_nextoptiondate() const;
  private:
  bool _internal_has_nextoptiondate() const;
  public:
  void clear_nextoptiondate();
  const std::string& nextoptiondate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nextoptiondate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nextoptiondate();
  PROTOBUF_NODISCARD std::string* release_nextoptiondate();
  void set_allocated_nextoptiondate(std::string* nextoptiondate);
  private:
  const std::string& _internal_nextoptiondate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextoptiondate(const std::string& value);
  std::string* _internal_mutable_nextoptiondate();
  public:

  // optional string nextOptionType = 55;
  bool has_nextoptiontype() const;
  private:
  bool _internal_has_nextoptiontype() const;
  public:
  void clear_nextoptiontype();
  const std::string& nextoptiontype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nextoptiontype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nextoptiontype();
  PROTOBUF_NODISCARD std::string* release_nextoptiontype();
  void set_allocated_nextoptiontype(std::string* nextoptiontype);
  private:
  const std::string& _internal_nextoptiontype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextoptiontype(const std::string& value);
  std::string* _internal_mutable_nextoptiontype();
  public:

  // optional string bondNotes = 57;
  bool has_bondnotes() const;
  private:
  bool _internal_has_bondnotes() const;
  public:
  void clear_bondnotes();
  const std::string& bondnotes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bondnotes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bondnotes();
  PROTOBUF_NODISCARD std::string* release_bondnotes();
  void set_allocated_bondnotes(std::string* bondnotes);
  private:
  const std::string& _internal_bondnotes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bondnotes(const std::string& value);
  std::string* _internal_mutable_bondnotes();
  public:

  // optional string eventContract1 = 59;
  bool has_eventcontract1() const;
  private:
  bool _internal_has_eventcontract1() const;
  public:
  void clear_eventcontract1();
  const std::string& eventcontract1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventcontract1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventcontract1();
  PROTOBUF_NODISCARD std::string* release_eventcontract1();
  void set_allocated_eventcontract1(std::string* eventcontract1);
  private:
  const std::string& _internal_eventcontract1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventcontract1(const std::string& value);
  std::string* _internal_mutable_eventcontract1();
  public:

  // optional string eventContractDescription1 = 60;
  bool has_eventcontractdescription1() const;
  private:
  bool _internal_has_eventcontractdescription1() const;
  public:
  void clear_eventcontractdescription1();
  const std::string& eventcontractdescription1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventcontractdescription1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventcontractdescription1();
  PROTOBUF_NODISCARD std::string* release_eventcontractdescription1();
  void set_allocated_eventcontractdescription1(std::string* eventcontractdescription1);
  private:
  const std::string& _internal_eventcontractdescription1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventcontractdescription1(const std::string& value);
  std::string* _internal_mutable_eventcontractdescription1();
  public:

  // optional string eventContractDescription2 = 61;
  bool has_eventcontractdescription2() const;
  private:
  bool _internal_has_eventcontractdescription2() const;
  public:
  void clear_eventcontractdescription2();
  const std::string& eventcontractdescription2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventcontractdescription2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventcontractdescription2();
  PROTOBUF_NODISCARD std::string* release_eventcontractdescription2();
  void set_allocated_eventcontractdescription2(std::string* eventcontractdescription2);
  private:
  const std::string& _internal_eventcontractdescription2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventcontractdescription2(const std::string& value);
  std::string* _internal_mutable_eventcontractdescription2();
  public:

  // optional string minAlgoSize = 62;
  bool has_minalgosize() const;
  private:
  bool _internal_has_minalgosize() const;
  public:
  void clear_minalgosize();
  const std::string& minalgosize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minalgosize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minalgosize();
  PROTOBUF_NODISCARD std::string* release_minalgosize();
  void set_allocated_minalgosize(std::string* minalgosize);
  private:
  const std::string& _internal_minalgosize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minalgosize(const std::string& value);
  std::string* _internal_mutable_minalgosize();
  public:

  // optional int32 priceMagnifier = 5;
  bool has_pricemagnifier() const;
  private:
  bool _internal_has_pricemagnifier() const;
  public:
  void clear_pricemagnifier();
  int32_t pricemagnifier() const;
  void set_pricemagnifier(int32_t value);
  private:
  int32_t _internal_pricemagnifier() const;
  void _internal_set_pricemagnifier(int32_t value);
  public:

  // optional int32 underConId = 6;
  bool has_underconid() const;
  private:
  bool _internal_has_underconid() const;
  public:
  void clear_underconid();
  int32_t underconid() const;
  void set_underconid(int32_t value);
  private:
  int32_t _internal_underconid() const;
  void _internal_set_underconid(int32_t value);
  public:

  // optional double evMultiplier = 16;
  bool has_evmultiplier() const;
  private:
  bool _internal_has_evmultiplier() const;
  public:
  void clear_evmultiplier();
  double evmultiplier() const;
  void set_evmultiplier(double value);
  private:
  double _internal_evmultiplier() const;
  void _internal_set_evmultiplier(double value);
  public:

  // optional int32 aggGroup = 18;
  bool has_agggroup() const;
  private:
  bool _internal_has_agggroup() const;
  public:
  void clear_agggroup();
  int32_t agggroup() const;
  void set_agggroup(int32_t value);
  private:
  int32_t _internal_agggroup() const;
  void _internal_set_agggroup(int32_t value);
  public:

  // optional bool fundClosed = 34;
  bool has_fundclosed() const;
  private:
  bool _internal_has_fundclosed() const;
  public:
  void clear_fundclosed();
  bool fundclosed() const;
  void set_fundclosed(bool value);
  private:
  bool _internal_fundclosed() const;
  void _internal_set_fundclosed(bool value);
  public:

  // optional bool fundClosedForNewInvestors = 35;
  bool has_fundclosedfornewinvestors() const;
  private:
  bool _internal_has_fundclosedfornewinvestors() const;
  public:
  void clear_fundclosedfornewinvestors();
  bool fundclosedfornewinvestors() const;
  void set_fundclosedfornewinvestors(bool value);
  private:
  bool _internal_fundclosedfornewinvestors() const;
  void _internal_set_fundclosedfornewinvestors(bool value);
  public:

  // optional bool fundClosedForNewMoney = 36;
  bool has_fundclosedfornewmoney() const;
  private:
  bool _internal_has_fundclosedfornewmoney() const;
  public:
  void clear_fundclosedfornewmoney();
  bool fundclosedfornewmoney() const;
  void set_fundclosedfornewmoney(bool value);
  private:
  bool _internal_fundclosedfornewmoney() const;
  void _internal_set_fundclosedfornewmoney(bool value);
  public:

  // optional bool convertible = 50;
  bool has_convertible() const;
  private:
  bool _internal_has_convertible() const;
  public:
  void clear_convertible();
  bool convertible() const;
  void set_convertible(bool value);
  private:
  bool _internal_convertible() const;
  void _internal_set_convertible(bool value);
  public:

  // optional double coupon = 48;
  bool has_coupon() const;
  private:
  bool _internal_has_coupon() const;
  public:
  void clear_coupon();
  double coupon() const;
  void set_coupon(double value);
  private:
  double _internal_coupon() const;
  void _internal_set_coupon(double value);
  public:

  // optional bool callable = 51;
  bool has_callable() const;
  private:
  bool _internal_has_callable() const;
  public:
  void clear_callable();
  bool callable() const;
  void set_callable(bool value);
  private:
  bool _internal_callable() const;
  void _internal_set_callable(bool value);
  public:

  // optional bool puttable = 52;
  bool has_puttable() const;
  private:
  bool _internal_has_puttable() const;
  public:
  void clear_puttable();
  bool puttable() const;
  void set_puttable(bool value);
  private:
  bool _internal_puttable() const;
  void _internal_set_puttable(bool value);
  public:

  // optional bool nextOptionPartial = 56;
  bool has_nextoptionpartial() const;
  private:
  bool _internal_has_nextoptionpartial() const;
  public:
  void clear_nextoptionpartial();
  bool nextoptionpartial() const;
  void set_nextoptionpartial(bool value);
  private:
  bool _internal_nextoptionpartial() const;
  void _internal_set_nextoptionpartial(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protobuf.ContractDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ContractDetails_SecIdListEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> secidlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::IneligibilityReason > ineligibilityreasonlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mintick_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ordertypes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validexchanges_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr longname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contractmonth_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr industry_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subcategory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezoneid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tradinghours_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liquidhours_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr evrule_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr undersymbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr undersectype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketruleids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realexpirationdate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stocktype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minsize_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sizeincrement_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suggestedsizeincrement_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundfamily_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundtype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundfrontload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundbackload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundbackloadtimeinterval_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundmanagementfee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundnotifyamount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundminimuminitialpurchase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundminimumsubsequentpurchase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundblueskystates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundblueskyterritories_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funddistributionpolicyindicator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fundassettype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cusip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuedate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ratings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bondtype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coupontype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr descappend_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nextoptiondate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nextoptiontype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bondnotes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventcontract1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventcontractdescription1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventcontractdescription2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minalgosize_;
    int32_t pricemagnifier_;
    int32_t underconid_;
    double evmultiplier_;
    int32_t agggroup_;
    bool fundclosed_;
    bool fundclosedfornewinvestors_;
    bool fundclosedfornewmoney_;
    bool convertible_;
    double coupon_;
    bool callable_;
    bool puttable_;
    bool nextoptionpartial_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ContractDetails_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ContractDetails

// optional string marketName = 1;
inline bool ContractDetails::_internal_has_marketname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractDetails::has_marketname() const {
  return _internal_has_marketname();
}
inline void ContractDetails::clear_marketname() {
  _impl_.marketname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractDetails::marketname() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.marketName)
  return _internal_marketname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_marketname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.marketname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.marketName)
}
inline std::string* ContractDetails::mutable_marketname() {
  std::string* _s = _internal_mutable_marketname();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.marketName)
  return _s;
}
inline const std::string& ContractDetails::_internal_marketname() const {
  return _impl_.marketname_.Get();
}
inline void ContractDetails::_internal_set_marketname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketname_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_marketname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.marketname_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_marketname() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.marketName)
  if (!_internal_has_marketname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.marketname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketname_.IsDefault()) {
    _impl_.marketname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_marketname(std::string* marketname) {
  if (marketname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.marketname_.SetAllocated(marketname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketname_.IsDefault()) {
    _impl_.marketname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.marketName)
}

// optional string minTick = 2;
inline bool ContractDetails::_internal_has_mintick() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractDetails::has_mintick() const {
  return _internal_has_mintick();
}
inline void ContractDetails::clear_mintick() {
  _impl_.mintick_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractDetails::mintick() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.minTick)
  return _internal_mintick();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_mintick(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mintick_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.minTick)
}
inline std::string* ContractDetails::mutable_mintick() {
  std::string* _s = _internal_mutable_mintick();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.minTick)
  return _s;
}
inline const std::string& ContractDetails::_internal_mintick() const {
  return _impl_.mintick_.Get();
}
inline void ContractDetails::_internal_set_mintick(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mintick_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_mintick() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mintick_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_mintick() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.minTick)
  if (!_internal_has_mintick()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mintick_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mintick_.IsDefault()) {
    _impl_.mintick_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_mintick(std::string* mintick) {
  if (mintick != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mintick_.SetAllocated(mintick, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mintick_.IsDefault()) {
    _impl_.mintick_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.minTick)
}

// optional string orderTypes = 3;
inline bool ContractDetails::_internal_has_ordertypes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractDetails::has_ordertypes() const {
  return _internal_has_ordertypes();
}
inline void ContractDetails::clear_ordertypes() {
  _impl_.ordertypes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContractDetails::ordertypes() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.orderTypes)
  return _internal_ordertypes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_ordertypes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.ordertypes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.orderTypes)
}
inline std::string* ContractDetails::mutable_ordertypes() {
  std::string* _s = _internal_mutable_ordertypes();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.orderTypes)
  return _s;
}
inline const std::string& ContractDetails::_internal_ordertypes() const {
  return _impl_.ordertypes_.Get();
}
inline void ContractDetails::_internal_set_ordertypes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ordertypes_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_ordertypes() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ordertypes_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_ordertypes() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.orderTypes)
  if (!_internal_has_ordertypes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.ordertypes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ordertypes_.IsDefault()) {
    _impl_.ordertypes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_ordertypes(std::string* ordertypes) {
  if (ordertypes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ordertypes_.SetAllocated(ordertypes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ordertypes_.IsDefault()) {
    _impl_.ordertypes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.orderTypes)
}

// optional string validExchanges = 4;
inline bool ContractDetails::_internal_has_validexchanges() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContractDetails::has_validexchanges() const {
  return _internal_has_validexchanges();
}
inline void ContractDetails::clear_validexchanges() {
  _impl_.validexchanges_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContractDetails::validexchanges() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.validExchanges)
  return _internal_validexchanges();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_validexchanges(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.validexchanges_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.validExchanges)
}
inline std::string* ContractDetails::mutable_validexchanges() {
  std::string* _s = _internal_mutable_validexchanges();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.validExchanges)
  return _s;
}
inline const std::string& ContractDetails::_internal_validexchanges() const {
  return _impl_.validexchanges_.Get();
}
inline void ContractDetails::_internal_set_validexchanges(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.validexchanges_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_validexchanges() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.validexchanges_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_validexchanges() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.validExchanges)
  if (!_internal_has_validexchanges()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.validexchanges_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.validexchanges_.IsDefault()) {
    _impl_.validexchanges_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_validexchanges(std::string* validexchanges) {
  if (validexchanges != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.validexchanges_.SetAllocated(validexchanges, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.validexchanges_.IsDefault()) {
    _impl_.validexchanges_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.validExchanges)
}

// optional int32 priceMagnifier = 5;
inline bool ContractDetails::_internal_has_pricemagnifier() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool ContractDetails::has_pricemagnifier() const {
  return _internal_has_pricemagnifier();
}
inline void ContractDetails::clear_pricemagnifier() {
  _impl_.pricemagnifier_ = 0;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline int32_t ContractDetails::_internal_pricemagnifier() const {
  return _impl_.pricemagnifier_;
}
inline int32_t ContractDetails::pricemagnifier() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.priceMagnifier)
  return _internal_pricemagnifier();
}
inline void ContractDetails::_internal_set_pricemagnifier(int32_t value) {
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.pricemagnifier_ = value;
}
inline void ContractDetails::set_pricemagnifier(int32_t value) {
  _internal_set_pricemagnifier(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.priceMagnifier)
}

// optional int32 underConId = 6;
inline bool ContractDetails::_internal_has_underconid() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool ContractDetails::has_underconid() const {
  return _internal_has_underconid();
}
inline void ContractDetails::clear_underconid() {
  _impl_.underconid_ = 0;
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline int32_t ContractDetails::_internal_underconid() const {
  return _impl_.underconid_;
}
inline int32_t ContractDetails::underconid() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.underConId)
  return _internal_underconid();
}
inline void ContractDetails::_internal_set_underconid(int32_t value) {
  _impl_._has_bits_[1] |= 0x00020000u;
  _impl_.underconid_ = value;
}
inline void ContractDetails::set_underconid(int32_t value) {
  _internal_set_underconid(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.underConId)
}

// optional string longName = 7;
inline bool ContractDetails::_internal_has_longname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContractDetails::has_longname() const {
  return _internal_has_longname();
}
inline void ContractDetails::clear_longname() {
  _impl_.longname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ContractDetails::longname() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.longName)
  return _internal_longname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_longname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.longname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.longName)
}
inline std::string* ContractDetails::mutable_longname() {
  std::string* _s = _internal_mutable_longname();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.longName)
  return _s;
}
inline const std::string& ContractDetails::_internal_longname() const {
  return _impl_.longname_.Get();
}
inline void ContractDetails::_internal_set_longname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.longname_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_longname() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.longname_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_longname() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.longName)
  if (!_internal_has_longname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.longname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.longname_.IsDefault()) {
    _impl_.longname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_longname(std::string* longname) {
  if (longname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.longname_.SetAllocated(longname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.longname_.IsDefault()) {
    _impl_.longname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.longName)
}

// optional string contractMonth = 8;
inline bool ContractDetails::_internal_has_contractmonth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContractDetails::has_contractmonth() const {
  return _internal_has_contractmonth();
}
inline void ContractDetails::clear_contractmonth() {
  _impl_.contractmonth_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ContractDetails::contractmonth() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.contractMonth)
  return _internal_contractmonth();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_contractmonth(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.contractmonth_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.contractMonth)
}
inline std::string* ContractDetails::mutable_contractmonth() {
  std::string* _s = _internal_mutable_contractmonth();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.contractMonth)
  return _s;
}
inline const std::string& ContractDetails::_internal_contractmonth() const {
  return _impl_.contractmonth_.Get();
}
inline void ContractDetails::_internal_set_contractmonth(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.contractmonth_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_contractmonth() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.contractmonth_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_contractmonth() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.contractMonth)
  if (!_internal_has_contractmonth()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.contractmonth_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contractmonth_.IsDefault()) {
    _impl_.contractmonth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_contractmonth(std::string* contractmonth) {
  if (contractmonth != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.contractmonth_.SetAllocated(contractmonth, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contractmonth_.IsDefault()) {
    _impl_.contractmonth_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.contractMonth)
}

// optional string industry = 9;
inline bool ContractDetails::_internal_has_industry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ContractDetails::has_industry() const {
  return _internal_has_industry();
}
inline void ContractDetails::clear_industry() {
  _impl_.industry_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ContractDetails::industry() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.industry)
  return _internal_industry();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_industry(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.industry_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.industry)
}
inline std::string* ContractDetails::mutable_industry() {
  std::string* _s = _internal_mutable_industry();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.industry)
  return _s;
}
inline const std::string& ContractDetails::_internal_industry() const {
  return _impl_.industry_.Get();
}
inline void ContractDetails::_internal_set_industry(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.industry_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_industry() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.industry_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_industry() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.industry)
  if (!_internal_has_industry()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.industry_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.industry_.IsDefault()) {
    _impl_.industry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_industry(std::string* industry) {
  if (industry != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.industry_.SetAllocated(industry, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.industry_.IsDefault()) {
    _impl_.industry_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.industry)
}

// optional string category = 10;
inline bool ContractDetails::_internal_has_category() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContractDetails::has_category() const {
  return _internal_has_category();
}
inline void ContractDetails::clear_category() {
  _impl_.category_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ContractDetails::category() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_category(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.category)
}
inline std::string* ContractDetails::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.category)
  return _s;
}
inline const std::string& ContractDetails::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ContractDetails::_internal_set_category(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_category() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_category() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.category)
  if (!_internal_has_category()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.category_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.category)
}

// optional string subcategory = 11;
inline bool ContractDetails::_internal_has_subcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ContractDetails::has_subcategory() const {
  return _internal_has_subcategory();
}
inline void ContractDetails::clear_subcategory() {
  _impl_.subcategory_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ContractDetails::subcategory() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.subcategory)
  return _internal_subcategory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_subcategory(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.subcategory_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.subcategory)
}
inline std::string* ContractDetails::mutable_subcategory() {
  std::string* _s = _internal_mutable_subcategory();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.subcategory)
  return _s;
}
inline const std::string& ContractDetails::_internal_subcategory() const {
  return _impl_.subcategory_.Get();
}
inline void ContractDetails::_internal_set_subcategory(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.subcategory_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_subcategory() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.subcategory_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_subcategory() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.subcategory)
  if (!_internal_has_subcategory()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.subcategory_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subcategory_.IsDefault()) {
    _impl_.subcategory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_subcategory(std::string* subcategory) {
  if (subcategory != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.subcategory_.SetAllocated(subcategory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subcategory_.IsDefault()) {
    _impl_.subcategory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.subcategory)
}

// optional string timeZoneId = 12;
inline bool ContractDetails::_internal_has_timezoneid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ContractDetails::has_timezoneid() const {
  return _internal_has_timezoneid();
}
inline void ContractDetails::clear_timezoneid() {
  _impl_.timezoneid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ContractDetails::timezoneid() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.timeZoneId)
  return _internal_timezoneid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_timezoneid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.timezoneid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.timeZoneId)
}
inline std::string* ContractDetails::mutable_timezoneid() {
  std::string* _s = _internal_mutable_timezoneid();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.timeZoneId)
  return _s;
}
inline const std::string& ContractDetails::_internal_timezoneid() const {
  return _impl_.timezoneid_.Get();
}
inline void ContractDetails::_internal_set_timezoneid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.timezoneid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_timezoneid() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.timezoneid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_timezoneid() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.timeZoneId)
  if (!_internal_has_timezoneid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.timezoneid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezoneid_.IsDefault()) {
    _impl_.timezoneid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_timezoneid(std::string* timezoneid) {
  if (timezoneid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.timezoneid_.SetAllocated(timezoneid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezoneid_.IsDefault()) {
    _impl_.timezoneid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.timeZoneId)
}

// optional string tradingHours = 13;
inline bool ContractDetails::_internal_has_tradinghours() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ContractDetails::has_tradinghours() const {
  return _internal_has_tradinghours();
}
inline void ContractDetails::clear_tradinghours() {
  _impl_.tradinghours_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ContractDetails::tradinghours() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.tradingHours)
  return _internal_tradinghours();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_tradinghours(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.tradinghours_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.tradingHours)
}
inline std::string* ContractDetails::mutable_tradinghours() {
  std::string* _s = _internal_mutable_tradinghours();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.tradingHours)
  return _s;
}
inline const std::string& ContractDetails::_internal_tradinghours() const {
  return _impl_.tradinghours_.Get();
}
inline void ContractDetails::_internal_set_tradinghours(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.tradinghours_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_tradinghours() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.tradinghours_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_tradinghours() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.tradingHours)
  if (!_internal_has_tradinghours()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.tradinghours_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradinghours_.IsDefault()) {
    _impl_.tradinghours_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_tradinghours(std::string* tradinghours) {
  if (tradinghours != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.tradinghours_.SetAllocated(tradinghours, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tradinghours_.IsDefault()) {
    _impl_.tradinghours_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.tradingHours)
}

// optional string liquidHours = 14;
inline bool ContractDetails::_internal_has_liquidhours() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ContractDetails::has_liquidhours() const {
  return _internal_has_liquidhours();
}
inline void ContractDetails::clear_liquidhours() {
  _impl_.liquidhours_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ContractDetails::liquidhours() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.liquidHours)
  return _internal_liquidhours();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_liquidhours(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.liquidhours_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.liquidHours)
}
inline std::string* ContractDetails::mutable_liquidhours() {
  std::string* _s = _internal_mutable_liquidhours();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.liquidHours)
  return _s;
}
inline const std::string& ContractDetails::_internal_liquidhours() const {
  return _impl_.liquidhours_.Get();
}
inline void ContractDetails::_internal_set_liquidhours(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.liquidhours_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_liquidhours() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.liquidhours_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_liquidhours() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.liquidHours)
  if (!_internal_has_liquidhours()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.liquidhours_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liquidhours_.IsDefault()) {
    _impl_.liquidhours_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_liquidhours(std::string* liquidhours) {
  if (liquidhours != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.liquidhours_.SetAllocated(liquidhours, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.liquidhours_.IsDefault()) {
    _impl_.liquidhours_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.liquidHours)
}

// optional string evRule = 15;
inline bool ContractDetails::_internal_has_evrule() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ContractDetails::has_evrule() const {
  return _internal_has_evrule();
}
inline void ContractDetails::clear_evrule() {
  _impl_.evrule_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& ContractDetails::evrule() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.evRule)
  return _internal_evrule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_evrule(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.evrule_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.evRule)
}
inline std::string* ContractDetails::mutable_evrule() {
  std::string* _s = _internal_mutable_evrule();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.evRule)
  return _s;
}
inline const std::string& ContractDetails::_internal_evrule() const {
  return _impl_.evrule_.Get();
}
inline void ContractDetails::_internal_set_evrule(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.evrule_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_evrule() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.evrule_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_evrule() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.evRule)
  if (!_internal_has_evrule()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.evrule_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.evrule_.IsDefault()) {
    _impl_.evrule_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_evrule(std::string* evrule) {
  if (evrule != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.evrule_.SetAllocated(evrule, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.evrule_.IsDefault()) {
    _impl_.evrule_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.evRule)
}

// optional double evMultiplier = 16;
inline bool ContractDetails::_internal_has_evmultiplier() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool ContractDetails::has_evmultiplier() const {
  return _internal_has_evmultiplier();
}
inline void ContractDetails::clear_evmultiplier() {
  _impl_.evmultiplier_ = 0;
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline double ContractDetails::_internal_evmultiplier() const {
  return _impl_.evmultiplier_;
}
inline double ContractDetails::evmultiplier() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.evMultiplier)
  return _internal_evmultiplier();
}
inline void ContractDetails::_internal_set_evmultiplier(double value) {
  _impl_._has_bits_[1] |= 0x00040000u;
  _impl_.evmultiplier_ = value;
}
inline void ContractDetails::set_evmultiplier(double value) {
  _internal_set_evmultiplier(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.evMultiplier)
}

// map<string, string> secIdList = 17;
inline int ContractDetails::_internal_secidlist_size() const {
  return _impl_.secidlist_.size();
}
inline int ContractDetails::secidlist_size() const {
  return _internal_secidlist_size();
}
inline void ContractDetails::clear_secidlist() {
  _impl_.secidlist_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ContractDetails::_internal_secidlist() const {
  return _impl_.secidlist_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ContractDetails::secidlist() const {
  // @@protoc_insertion_point(field_map:protobuf.ContractDetails.secIdList)
  return _internal_secidlist();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ContractDetails::_internal_mutable_secidlist() {
  return _impl_.secidlist_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ContractDetails::mutable_secidlist() {
  // @@protoc_insertion_point(field_mutable_map:protobuf.ContractDetails.secIdList)
  return _internal_mutable_secidlist();
}

// optional int32 aggGroup = 18;
inline bool ContractDetails::_internal_has_agggroup() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool ContractDetails::has_agggroup() const {
  return _internal_has_agggroup();
}
inline void ContractDetails::clear_agggroup() {
  _impl_.agggroup_ = 0;
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline int32_t ContractDetails::_internal_agggroup() const {
  return _impl_.agggroup_;
}
inline int32_t ContractDetails::agggroup() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.aggGroup)
  return _internal_agggroup();
}
inline void ContractDetails::_internal_set_agggroup(int32_t value) {
  _impl_._has_bits_[1] |= 0x00080000u;
  _impl_.agggroup_ = value;
}
inline void ContractDetails::set_agggroup(int32_t value) {
  _internal_set_agggroup(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.aggGroup)
}

// optional string underSymbol = 19;
inline bool ContractDetails::_internal_has_undersymbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ContractDetails::has_undersymbol() const {
  return _internal_has_undersymbol();
}
inline void ContractDetails::clear_undersymbol() {
  _impl_.undersymbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& ContractDetails::undersymbol() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.underSymbol)
  return _internal_undersymbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_undersymbol(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.undersymbol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.underSymbol)
}
inline std::string* ContractDetails::mutable_undersymbol() {
  std::string* _s = _internal_mutable_undersymbol();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.underSymbol)
  return _s;
}
inline const std::string& ContractDetails::_internal_undersymbol() const {
  return _impl_.undersymbol_.Get();
}
inline void ContractDetails::_internal_set_undersymbol(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.undersymbol_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_undersymbol() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.undersymbol_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_undersymbol() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.underSymbol)
  if (!_internal_has_undersymbol()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.undersymbol_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.undersymbol_.IsDefault()) {
    _impl_.undersymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_undersymbol(std::string* undersymbol) {
  if (undersymbol != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.undersymbol_.SetAllocated(undersymbol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.undersymbol_.IsDefault()) {
    _impl_.undersymbol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.underSymbol)
}

// optional string underSecType = 20;
inline bool ContractDetails::_internal_has_undersectype() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ContractDetails::has_undersectype() const {
  return _internal_has_undersectype();
}
inline void ContractDetails::clear_undersectype() {
  _impl_.undersectype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& ContractDetails::undersectype() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.underSecType)
  return _internal_undersectype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_undersectype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.undersectype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.underSecType)
}
inline std::string* ContractDetails::mutable_undersectype() {
  std::string* _s = _internal_mutable_undersectype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.underSecType)
  return _s;
}
inline const std::string& ContractDetails::_internal_undersectype() const {
  return _impl_.undersectype_.Get();
}
inline void ContractDetails::_internal_set_undersectype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.undersectype_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_undersectype() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.undersectype_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_undersectype() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.underSecType)
  if (!_internal_has_undersectype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.undersectype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.undersectype_.IsDefault()) {
    _impl_.undersectype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_undersectype(std::string* undersectype) {
  if (undersectype != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.undersectype_.SetAllocated(undersectype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.undersectype_.IsDefault()) {
    _impl_.undersectype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.underSecType)
}

// optional string marketRuleIds = 21;
inline bool ContractDetails::_internal_has_marketruleids() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ContractDetails::has_marketruleids() const {
  return _internal_has_marketruleids();
}
inline void ContractDetails::clear_marketruleids() {
  _impl_.marketruleids_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& ContractDetails::marketruleids() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.marketRuleIds)
  return _internal_marketruleids();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_marketruleids(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00008000u;
 _impl_.marketruleids_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.marketRuleIds)
}
inline std::string* ContractDetails::mutable_marketruleids() {
  std::string* _s = _internal_mutable_marketruleids();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.marketRuleIds)
  return _s;
}
inline const std::string& ContractDetails::_internal_marketruleids() const {
  return _impl_.marketruleids_.Get();
}
inline void ContractDetails::_internal_set_marketruleids(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.marketruleids_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_marketruleids() {
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.marketruleids_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_marketruleids() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.marketRuleIds)
  if (!_internal_has_marketruleids()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* p = _impl_.marketruleids_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketruleids_.IsDefault()) {
    _impl_.marketruleids_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_marketruleids(std::string* marketruleids) {
  if (marketruleids != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.marketruleids_.SetAllocated(marketruleids, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.marketruleids_.IsDefault()) {
    _impl_.marketruleids_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.marketRuleIds)
}

// optional string realExpirationDate = 22;
inline bool ContractDetails::_internal_has_realexpirationdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ContractDetails::has_realexpirationdate() const {
  return _internal_has_realexpirationdate();
}
inline void ContractDetails::clear_realexpirationdate() {
  _impl_.realexpirationdate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& ContractDetails::realexpirationdate() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.realExpirationDate)
  return _internal_realexpirationdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_realexpirationdate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00010000u;
 _impl_.realexpirationdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.realExpirationDate)
}
inline std::string* ContractDetails::mutable_realexpirationdate() {
  std::string* _s = _internal_mutable_realexpirationdate();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.realExpirationDate)
  return _s;
}
inline const std::string& ContractDetails::_internal_realexpirationdate() const {
  return _impl_.realexpirationdate_.Get();
}
inline void ContractDetails::_internal_set_realexpirationdate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.realexpirationdate_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_realexpirationdate() {
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.realexpirationdate_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_realexpirationdate() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.realExpirationDate)
  if (!_internal_has_realexpirationdate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* p = _impl_.realexpirationdate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realexpirationdate_.IsDefault()) {
    _impl_.realexpirationdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_realexpirationdate(std::string* realexpirationdate) {
  if (realexpirationdate != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.realexpirationdate_.SetAllocated(realexpirationdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realexpirationdate_.IsDefault()) {
    _impl_.realexpirationdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.realExpirationDate)
}

// optional string stockType = 23;
inline bool ContractDetails::_internal_has_stocktype() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ContractDetails::has_stocktype() const {
  return _internal_has_stocktype();
}
inline void ContractDetails::clear_stocktype() {
  _impl_.stocktype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& ContractDetails::stocktype() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.stockType)
  return _internal_stocktype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_stocktype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00020000u;
 _impl_.stocktype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.stockType)
}
inline std::string* ContractDetails::mutable_stocktype() {
  std::string* _s = _internal_mutable_stocktype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.stockType)
  return _s;
}
inline const std::string& ContractDetails::_internal_stocktype() const {
  return _impl_.stocktype_.Get();
}
inline void ContractDetails::_internal_set_stocktype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.stocktype_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_stocktype() {
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.stocktype_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_stocktype() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.stockType)
  if (!_internal_has_stocktype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* p = _impl_.stocktype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stocktype_.IsDefault()) {
    _impl_.stocktype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_stocktype(std::string* stocktype) {
  if (stocktype != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.stocktype_.SetAllocated(stocktype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stocktype_.IsDefault()) {
    _impl_.stocktype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.stockType)
}

// optional string minSize = 24;
inline bool ContractDetails::_internal_has_minsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ContractDetails::has_minsize() const {
  return _internal_has_minsize();
}
inline void ContractDetails::clear_minsize() {
  _impl_.minsize_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const std::string& ContractDetails::minsize() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.minSize)
  return _internal_minsize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_minsize(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00040000u;
 _impl_.minsize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.minSize)
}
inline std::string* ContractDetails::mutable_minsize() {
  std::string* _s = _internal_mutable_minsize();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.minSize)
  return _s;
}
inline const std::string& ContractDetails::_internal_minsize() const {
  return _impl_.minsize_.Get();
}
inline void ContractDetails::_internal_set_minsize(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.minsize_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_minsize() {
  _impl_._has_bits_[0] |= 0x00040000u;
  return _impl_.minsize_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_minsize() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.minSize)
  if (!_internal_has_minsize()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00040000u;
  auto* p = _impl_.minsize_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.minsize_.IsDefault()) {
    _impl_.minsize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_minsize(std::string* minsize) {
  if (minsize != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.minsize_.SetAllocated(minsize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.minsize_.IsDefault()) {
    _impl_.minsize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.minSize)
}

// optional string sizeIncrement = 25;
inline bool ContractDetails::_internal_has_sizeincrement() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ContractDetails::has_sizeincrement() const {
  return _internal_has_sizeincrement();
}
inline void ContractDetails::clear_sizeincrement() {
  _impl_.sizeincrement_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const std::string& ContractDetails::sizeincrement() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.sizeIncrement)
  return _internal_sizeincrement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_sizeincrement(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00080000u;
 _impl_.sizeincrement_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.sizeIncrement)
}
inline std::string* ContractDetails::mutable_sizeincrement() {
  std::string* _s = _internal_mutable_sizeincrement();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.sizeIncrement)
  return _s;
}
inline const std::string& ContractDetails::_internal_sizeincrement() const {
  return _impl_.sizeincrement_.Get();
}
inline void ContractDetails::_internal_set_sizeincrement(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.sizeincrement_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_sizeincrement() {
  _impl_._has_bits_[0] |= 0x00080000u;
  return _impl_.sizeincrement_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_sizeincrement() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.sizeIncrement)
  if (!_internal_has_sizeincrement()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00080000u;
  auto* p = _impl_.sizeincrement_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sizeincrement_.IsDefault()) {
    _impl_.sizeincrement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_sizeincrement(std::string* sizeincrement) {
  if (sizeincrement != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.sizeincrement_.SetAllocated(sizeincrement, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sizeincrement_.IsDefault()) {
    _impl_.sizeincrement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.sizeIncrement)
}

// optional string suggestedSizeIncrement = 26;
inline bool ContractDetails::_internal_has_suggestedsizeincrement() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ContractDetails::has_suggestedsizeincrement() const {
  return _internal_has_suggestedsizeincrement();
}
inline void ContractDetails::clear_suggestedsizeincrement() {
  _impl_.suggestedsizeincrement_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const std::string& ContractDetails::suggestedsizeincrement() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.suggestedSizeIncrement)
  return _internal_suggestedsizeincrement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_suggestedsizeincrement(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00100000u;
 _impl_.suggestedsizeincrement_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.suggestedSizeIncrement)
}
inline std::string* ContractDetails::mutable_suggestedsizeincrement() {
  std::string* _s = _internal_mutable_suggestedsizeincrement();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.suggestedSizeIncrement)
  return _s;
}
inline const std::string& ContractDetails::_internal_suggestedsizeincrement() const {
  return _impl_.suggestedsizeincrement_.Get();
}
inline void ContractDetails::_internal_set_suggestedsizeincrement(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.suggestedsizeincrement_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_suggestedsizeincrement() {
  _impl_._has_bits_[0] |= 0x00100000u;
  return _impl_.suggestedsizeincrement_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_suggestedsizeincrement() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.suggestedSizeIncrement)
  if (!_internal_has_suggestedsizeincrement()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00100000u;
  auto* p = _impl_.suggestedsizeincrement_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.suggestedsizeincrement_.IsDefault()) {
    _impl_.suggestedsizeincrement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_suggestedsizeincrement(std::string* suggestedsizeincrement) {
  if (suggestedsizeincrement != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.suggestedsizeincrement_.SetAllocated(suggestedsizeincrement, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.suggestedsizeincrement_.IsDefault()) {
    _impl_.suggestedsizeincrement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.suggestedSizeIncrement)
}

// optional string fundName = 27;
inline bool ContractDetails::_internal_has_fundname() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundname() const {
  return _internal_has_fundname();
}
inline void ContractDetails::clear_fundname() {
  _impl_.fundname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const std::string& ContractDetails::fundname() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundName)
  return _internal_fundname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00200000u;
 _impl_.fundname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundName)
}
inline std::string* ContractDetails::mutable_fundname() {
  std::string* _s = _internal_mutable_fundname();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundName)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundname() const {
  return _impl_.fundname_.Get();
}
inline void ContractDetails::_internal_set_fundname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.fundname_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundname() {
  _impl_._has_bits_[0] |= 0x00200000u;
  return _impl_.fundname_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundname() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundName)
  if (!_internal_has_fundname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00200000u;
  auto* p = _impl_.fundname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundname_.IsDefault()) {
    _impl_.fundname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundname(std::string* fundname) {
  if (fundname != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.fundname_.SetAllocated(fundname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundname_.IsDefault()) {
    _impl_.fundname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundName)
}

// optional string fundFamily = 28;
inline bool ContractDetails::_internal_has_fundfamily() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundfamily() const {
  return _internal_has_fundfamily();
}
inline void ContractDetails::clear_fundfamily() {
  _impl_.fundfamily_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const std::string& ContractDetails::fundfamily() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundFamily)
  return _internal_fundfamily();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundfamily(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00400000u;
 _impl_.fundfamily_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundFamily)
}
inline std::string* ContractDetails::mutable_fundfamily() {
  std::string* _s = _internal_mutable_fundfamily();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundFamily)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundfamily() const {
  return _impl_.fundfamily_.Get();
}
inline void ContractDetails::_internal_set_fundfamily(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.fundfamily_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundfamily() {
  _impl_._has_bits_[0] |= 0x00400000u;
  return _impl_.fundfamily_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundfamily() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundFamily)
  if (!_internal_has_fundfamily()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00400000u;
  auto* p = _impl_.fundfamily_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundfamily_.IsDefault()) {
    _impl_.fundfamily_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundfamily(std::string* fundfamily) {
  if (fundfamily != nullptr) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.fundfamily_.SetAllocated(fundfamily, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundfamily_.IsDefault()) {
    _impl_.fundfamily_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundFamily)
}

// optional string fundType = 29;
inline bool ContractDetails::_internal_has_fundtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundtype() const {
  return _internal_has_fundtype();
}
inline void ContractDetails::clear_fundtype() {
  _impl_.fundtype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const std::string& ContractDetails::fundtype() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundType)
  return _internal_fundtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundtype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00800000u;
 _impl_.fundtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundType)
}
inline std::string* ContractDetails::mutable_fundtype() {
  std::string* _s = _internal_mutable_fundtype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundType)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundtype() const {
  return _impl_.fundtype_.Get();
}
inline void ContractDetails::_internal_set_fundtype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.fundtype_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundtype() {
  _impl_._has_bits_[0] |= 0x00800000u;
  return _impl_.fundtype_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundtype() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundType)
  if (!_internal_has_fundtype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00800000u;
  auto* p = _impl_.fundtype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundtype_.IsDefault()) {
    _impl_.fundtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundtype(std::string* fundtype) {
  if (fundtype != nullptr) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.fundtype_.SetAllocated(fundtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundtype_.IsDefault()) {
    _impl_.fundtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundType)
}

// optional string fundFrontLoad = 30;
inline bool ContractDetails::_internal_has_fundfrontload() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundfrontload() const {
  return _internal_has_fundfrontload();
}
inline void ContractDetails::clear_fundfrontload() {
  _impl_.fundfrontload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const std::string& ContractDetails::fundfrontload() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundFrontLoad)
  return _internal_fundfrontload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundfrontload(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x01000000u;
 _impl_.fundfrontload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundFrontLoad)
}
inline std::string* ContractDetails::mutable_fundfrontload() {
  std::string* _s = _internal_mutable_fundfrontload();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundFrontLoad)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundfrontload() const {
  return _impl_.fundfrontload_.Get();
}
inline void ContractDetails::_internal_set_fundfrontload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.fundfrontload_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundfrontload() {
  _impl_._has_bits_[0] |= 0x01000000u;
  return _impl_.fundfrontload_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundfrontload() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundFrontLoad)
  if (!_internal_has_fundfrontload()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x01000000u;
  auto* p = _impl_.fundfrontload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundfrontload_.IsDefault()) {
    _impl_.fundfrontload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundfrontload(std::string* fundfrontload) {
  if (fundfrontload != nullptr) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.fundfrontload_.SetAllocated(fundfrontload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundfrontload_.IsDefault()) {
    _impl_.fundfrontload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundFrontLoad)
}

// optional string fundBackLoad = 31;
inline bool ContractDetails::_internal_has_fundbackload() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundbackload() const {
  return _internal_has_fundbackload();
}
inline void ContractDetails::clear_fundbackload() {
  _impl_.fundbackload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const std::string& ContractDetails::fundbackload() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBackLoad)
  return _internal_fundbackload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundbackload(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x02000000u;
 _impl_.fundbackload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBackLoad)
}
inline std::string* ContractDetails::mutable_fundbackload() {
  std::string* _s = _internal_mutable_fundbackload();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBackLoad)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundbackload() const {
  return _impl_.fundbackload_.Get();
}
inline void ContractDetails::_internal_set_fundbackload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.fundbackload_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundbackload() {
  _impl_._has_bits_[0] |= 0x02000000u;
  return _impl_.fundbackload_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundbackload() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBackLoad)
  if (!_internal_has_fundbackload()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x02000000u;
  auto* p = _impl_.fundbackload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundbackload_.IsDefault()) {
    _impl_.fundbackload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundbackload(std::string* fundbackload) {
  if (fundbackload != nullptr) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.fundbackload_.SetAllocated(fundbackload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundbackload_.IsDefault()) {
    _impl_.fundbackload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBackLoad)
}

// optional string fundBackLoadTimeInterval = 32;
inline bool ContractDetails::_internal_has_fundbackloadtimeinterval() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundbackloadtimeinterval() const {
  return _internal_has_fundbackloadtimeinterval();
}
inline void ContractDetails::clear_fundbackloadtimeinterval() {
  _impl_.fundbackloadtimeinterval_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const std::string& ContractDetails::fundbackloadtimeinterval() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBackLoadTimeInterval)
  return _internal_fundbackloadtimeinterval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundbackloadtimeinterval(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x04000000u;
 _impl_.fundbackloadtimeinterval_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBackLoadTimeInterval)
}
inline std::string* ContractDetails::mutable_fundbackloadtimeinterval() {
  std::string* _s = _internal_mutable_fundbackloadtimeinterval();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBackLoadTimeInterval)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundbackloadtimeinterval() const {
  return _impl_.fundbackloadtimeinterval_.Get();
}
inline void ContractDetails::_internal_set_fundbackloadtimeinterval(const std::string& value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.fundbackloadtimeinterval_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundbackloadtimeinterval() {
  _impl_._has_bits_[0] |= 0x04000000u;
  return _impl_.fundbackloadtimeinterval_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundbackloadtimeinterval() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBackLoadTimeInterval)
  if (!_internal_has_fundbackloadtimeinterval()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x04000000u;
  auto* p = _impl_.fundbackloadtimeinterval_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundbackloadtimeinterval_.IsDefault()) {
    _impl_.fundbackloadtimeinterval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundbackloadtimeinterval(std::string* fundbackloadtimeinterval) {
  if (fundbackloadtimeinterval != nullptr) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.fundbackloadtimeinterval_.SetAllocated(fundbackloadtimeinterval, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundbackloadtimeinterval_.IsDefault()) {
    _impl_.fundbackloadtimeinterval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBackLoadTimeInterval)
}

// optional string fundManagementFee = 33;
inline bool ContractDetails::_internal_has_fundmanagementfee() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundmanagementfee() const {
  return _internal_has_fundmanagementfee();
}
inline void ContractDetails::clear_fundmanagementfee() {
  _impl_.fundmanagementfee_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const std::string& ContractDetails::fundmanagementfee() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundManagementFee)
  return _internal_fundmanagementfee();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundmanagementfee(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x08000000u;
 _impl_.fundmanagementfee_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundManagementFee)
}
inline std::string* ContractDetails::mutable_fundmanagementfee() {
  std::string* _s = _internal_mutable_fundmanagementfee();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundManagementFee)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundmanagementfee() const {
  return _impl_.fundmanagementfee_.Get();
}
inline void ContractDetails::_internal_set_fundmanagementfee(const std::string& value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.fundmanagementfee_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundmanagementfee() {
  _impl_._has_bits_[0] |= 0x08000000u;
  return _impl_.fundmanagementfee_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundmanagementfee() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundManagementFee)
  if (!_internal_has_fundmanagementfee()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x08000000u;
  auto* p = _impl_.fundmanagementfee_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundmanagementfee_.IsDefault()) {
    _impl_.fundmanagementfee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundmanagementfee(std::string* fundmanagementfee) {
  if (fundmanagementfee != nullptr) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.fundmanagementfee_.SetAllocated(fundmanagementfee, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundmanagementfee_.IsDefault()) {
    _impl_.fundmanagementfee_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundManagementFee)
}

// optional bool fundClosed = 34;
inline bool ContractDetails::_internal_has_fundclosed() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundclosed() const {
  return _internal_has_fundclosed();
}
inline void ContractDetails::clear_fundclosed() {
  _impl_.fundclosed_ = false;
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline bool ContractDetails::_internal_fundclosed() const {
  return _impl_.fundclosed_;
}
inline bool ContractDetails::fundclosed() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundClosed)
  return _internal_fundclosed();
}
inline void ContractDetails::_internal_set_fundclosed(bool value) {
  _impl_._has_bits_[1] |= 0x00100000u;
  _impl_.fundclosed_ = value;
}
inline void ContractDetails::set_fundclosed(bool value) {
  _internal_set_fundclosed(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundClosed)
}

// optional bool fundClosedForNewInvestors = 35;
inline bool ContractDetails::_internal_has_fundclosedfornewinvestors() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundclosedfornewinvestors() const {
  return _internal_has_fundclosedfornewinvestors();
}
inline void ContractDetails::clear_fundclosedfornewinvestors() {
  _impl_.fundclosedfornewinvestors_ = false;
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline bool ContractDetails::_internal_fundclosedfornewinvestors() const {
  return _impl_.fundclosedfornewinvestors_;
}
inline bool ContractDetails::fundclosedfornewinvestors() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundClosedForNewInvestors)
  return _internal_fundclosedfornewinvestors();
}
inline void ContractDetails::_internal_set_fundclosedfornewinvestors(bool value) {
  _impl_._has_bits_[1] |= 0x00200000u;
  _impl_.fundclosedfornewinvestors_ = value;
}
inline void ContractDetails::set_fundclosedfornewinvestors(bool value) {
  _internal_set_fundclosedfornewinvestors(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundClosedForNewInvestors)
}

// optional bool fundClosedForNewMoney = 36;
inline bool ContractDetails::_internal_has_fundclosedfornewmoney() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundclosedfornewmoney() const {
  return _internal_has_fundclosedfornewmoney();
}
inline void ContractDetails::clear_fundclosedfornewmoney() {
  _impl_.fundclosedfornewmoney_ = false;
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline bool ContractDetails::_internal_fundclosedfornewmoney() const {
  return _impl_.fundclosedfornewmoney_;
}
inline bool ContractDetails::fundclosedfornewmoney() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundClosedForNewMoney)
  return _internal_fundclosedfornewmoney();
}
inline void ContractDetails::_internal_set_fundclosedfornewmoney(bool value) {
  _impl_._has_bits_[1] |= 0x00400000u;
  _impl_.fundclosedfornewmoney_ = value;
}
inline void ContractDetails::set_fundclosedfornewmoney(bool value) {
  _internal_set_fundclosedfornewmoney(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundClosedForNewMoney)
}

// optional string fundNotifyAmount = 37;
inline bool ContractDetails::_internal_has_fundnotifyamount() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundnotifyamount() const {
  return _internal_has_fundnotifyamount();
}
inline void ContractDetails::clear_fundnotifyamount() {
  _impl_.fundnotifyamount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const std::string& ContractDetails::fundnotifyamount() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundNotifyAmount)
  return _internal_fundnotifyamount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundnotifyamount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x10000000u;
 _impl_.fundnotifyamount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundNotifyAmount)
}
inline std::string* ContractDetails::mutable_fundnotifyamount() {
  std::string* _s = _internal_mutable_fundnotifyamount();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundNotifyAmount)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundnotifyamount() const {
  return _impl_.fundnotifyamount_.Get();
}
inline void ContractDetails::_internal_set_fundnotifyamount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.fundnotifyamount_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundnotifyamount() {
  _impl_._has_bits_[0] |= 0x10000000u;
  return _impl_.fundnotifyamount_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundnotifyamount() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundNotifyAmount)
  if (!_internal_has_fundnotifyamount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x10000000u;
  auto* p = _impl_.fundnotifyamount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundnotifyamount_.IsDefault()) {
    _impl_.fundnotifyamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundnotifyamount(std::string* fundnotifyamount) {
  if (fundnotifyamount != nullptr) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.fundnotifyamount_.SetAllocated(fundnotifyamount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundnotifyamount_.IsDefault()) {
    _impl_.fundnotifyamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundNotifyAmount)
}

// optional string fundMinimumInitialPurchase = 38;
inline bool ContractDetails::_internal_has_fundminimuminitialpurchase() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundminimuminitialpurchase() const {
  return _internal_has_fundminimuminitialpurchase();
}
inline void ContractDetails::clear_fundminimuminitialpurchase() {
  _impl_.fundminimuminitialpurchase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const std::string& ContractDetails::fundminimuminitialpurchase() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundMinimumInitialPurchase)
  return _internal_fundminimuminitialpurchase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundminimuminitialpurchase(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x20000000u;
 _impl_.fundminimuminitialpurchase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundMinimumInitialPurchase)
}
inline std::string* ContractDetails::mutable_fundminimuminitialpurchase() {
  std::string* _s = _internal_mutable_fundminimuminitialpurchase();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundMinimumInitialPurchase)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundminimuminitialpurchase() const {
  return _impl_.fundminimuminitialpurchase_.Get();
}
inline void ContractDetails::_internal_set_fundminimuminitialpurchase(const std::string& value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.fundminimuminitialpurchase_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundminimuminitialpurchase() {
  _impl_._has_bits_[0] |= 0x20000000u;
  return _impl_.fundminimuminitialpurchase_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundminimuminitialpurchase() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundMinimumInitialPurchase)
  if (!_internal_has_fundminimuminitialpurchase()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x20000000u;
  auto* p = _impl_.fundminimuminitialpurchase_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundminimuminitialpurchase_.IsDefault()) {
    _impl_.fundminimuminitialpurchase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundminimuminitialpurchase(std::string* fundminimuminitialpurchase) {
  if (fundminimuminitialpurchase != nullptr) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.fundminimuminitialpurchase_.SetAllocated(fundminimuminitialpurchase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundminimuminitialpurchase_.IsDefault()) {
    _impl_.fundminimuminitialpurchase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundMinimumInitialPurchase)
}

// optional string fundMinimumSubsequentPurchase = 39;
inline bool ContractDetails::_internal_has_fundminimumsubsequentpurchase() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundminimumsubsequentpurchase() const {
  return _internal_has_fundminimumsubsequentpurchase();
}
inline void ContractDetails::clear_fundminimumsubsequentpurchase() {
  _impl_.fundminimumsubsequentpurchase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const std::string& ContractDetails::fundminimumsubsequentpurchase() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
  return _internal_fundminimumsubsequentpurchase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundminimumsubsequentpurchase(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x40000000u;
 _impl_.fundminimumsubsequentpurchase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
}
inline std::string* ContractDetails::mutable_fundminimumsubsequentpurchase() {
  std::string* _s = _internal_mutable_fundminimumsubsequentpurchase();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundminimumsubsequentpurchase() const {
  return _impl_.fundminimumsubsequentpurchase_.Get();
}
inline void ContractDetails::_internal_set_fundminimumsubsequentpurchase(const std::string& value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.fundminimumsubsequentpurchase_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundminimumsubsequentpurchase() {
  _impl_._has_bits_[0] |= 0x40000000u;
  return _impl_.fundminimumsubsequentpurchase_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundminimumsubsequentpurchase() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
  if (!_internal_has_fundminimumsubsequentpurchase()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x40000000u;
  auto* p = _impl_.fundminimumsubsequentpurchase_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundminimumsubsequentpurchase_.IsDefault()) {
    _impl_.fundminimumsubsequentpurchase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundminimumsubsequentpurchase(std::string* fundminimumsubsequentpurchase) {
  if (fundminimumsubsequentpurchase != nullptr) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.fundminimumsubsequentpurchase_.SetAllocated(fundminimumsubsequentpurchase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundminimumsubsequentpurchase_.IsDefault()) {
    _impl_.fundminimumsubsequentpurchase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundMinimumSubsequentPurchase)
}

// optional string fundBlueSkyStates = 40;
inline bool ContractDetails::_internal_has_fundblueskystates() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool ContractDetails::has_fundblueskystates() const {
  return _internal_has_fundblueskystates();
}
inline void ContractDetails::clear_fundblueskystates() {
  _impl_.fundblueskystates_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const std::string& ContractDetails::fundblueskystates() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBlueSkyStates)
  return _internal_fundblueskystates();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundblueskystates(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x80000000u;
 _impl_.fundblueskystates_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBlueSkyStates)
}
inline std::string* ContractDetails::mutable_fundblueskystates() {
  std::string* _s = _internal_mutable_fundblueskystates();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBlueSkyStates)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundblueskystates() const {
  return _impl_.fundblueskystates_.Get();
}
inline void ContractDetails::_internal_set_fundblueskystates(const std::string& value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.fundblueskystates_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundblueskystates() {
  _impl_._has_bits_[0] |= 0x80000000u;
  return _impl_.fundblueskystates_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundblueskystates() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBlueSkyStates)
  if (!_internal_has_fundblueskystates()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x80000000u;
  auto* p = _impl_.fundblueskystates_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundblueskystates_.IsDefault()) {
    _impl_.fundblueskystates_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundblueskystates(std::string* fundblueskystates) {
  if (fundblueskystates != nullptr) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.fundblueskystates_.SetAllocated(fundblueskystates, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundblueskystates_.IsDefault()) {
    _impl_.fundblueskystates_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBlueSkyStates)
}

// optional string fundBlueSkyTerritories = 41;
inline bool ContractDetails::_internal_has_fundblueskyterritories() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool ContractDetails::has_fundblueskyterritories() const {
  return _internal_has_fundblueskyterritories();
}
inline void ContractDetails::clear_fundblueskyterritories() {
  _impl_.fundblueskyterritories_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const std::string& ContractDetails::fundblueskyterritories() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundBlueSkyTerritories)
  return _internal_fundblueskyterritories();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundblueskyterritories(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000001u;
 _impl_.fundblueskyterritories_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundBlueSkyTerritories)
}
inline std::string* ContractDetails::mutable_fundblueskyterritories() {
  std::string* _s = _internal_mutable_fundblueskyterritories();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundBlueSkyTerritories)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundblueskyterritories() const {
  return _impl_.fundblueskyterritories_.Get();
}
inline void ContractDetails::_internal_set_fundblueskyterritories(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.fundblueskyterritories_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundblueskyterritories() {
  _impl_._has_bits_[1] |= 0x00000001u;
  return _impl_.fundblueskyterritories_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundblueskyterritories() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundBlueSkyTerritories)
  if (!_internal_has_fundblueskyterritories()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000001u;
  auto* p = _impl_.fundblueskyterritories_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundblueskyterritories_.IsDefault()) {
    _impl_.fundblueskyterritories_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundblueskyterritories(std::string* fundblueskyterritories) {
  if (fundblueskyterritories != nullptr) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.fundblueskyterritories_.SetAllocated(fundblueskyterritories, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundblueskyterritories_.IsDefault()) {
    _impl_.fundblueskyterritories_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundBlueSkyTerritories)
}

// optional string fundDistributionPolicyIndicator = 42;
inline bool ContractDetails::_internal_has_funddistributionpolicyindicator() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool ContractDetails::has_funddistributionpolicyindicator() const {
  return _internal_has_funddistributionpolicyindicator();
}
inline void ContractDetails::clear_funddistributionpolicyindicator() {
  _impl_.funddistributionpolicyindicator_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const std::string& ContractDetails::funddistributionpolicyindicator() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundDistributionPolicyIndicator)
  return _internal_funddistributionpolicyindicator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_funddistributionpolicyindicator(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000002u;
 _impl_.funddistributionpolicyindicator_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundDistributionPolicyIndicator)
}
inline std::string* ContractDetails::mutable_funddistributionpolicyindicator() {
  std::string* _s = _internal_mutable_funddistributionpolicyindicator();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundDistributionPolicyIndicator)
  return _s;
}
inline const std::string& ContractDetails::_internal_funddistributionpolicyindicator() const {
  return _impl_.funddistributionpolicyindicator_.Get();
}
inline void ContractDetails::_internal_set_funddistributionpolicyindicator(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.funddistributionpolicyindicator_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_funddistributionpolicyindicator() {
  _impl_._has_bits_[1] |= 0x00000002u;
  return _impl_.funddistributionpolicyindicator_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_funddistributionpolicyindicator() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundDistributionPolicyIndicator)
  if (!_internal_has_funddistributionpolicyindicator()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000002u;
  auto* p = _impl_.funddistributionpolicyindicator_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.funddistributionpolicyindicator_.IsDefault()) {
    _impl_.funddistributionpolicyindicator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_funddistributionpolicyindicator(std::string* funddistributionpolicyindicator) {
  if (funddistributionpolicyindicator != nullptr) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.funddistributionpolicyindicator_.SetAllocated(funddistributionpolicyindicator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.funddistributionpolicyindicator_.IsDefault()) {
    _impl_.funddistributionpolicyindicator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundDistributionPolicyIndicator)
}

// optional string fundAssetType = 43;
inline bool ContractDetails::_internal_has_fundassettype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool ContractDetails::has_fundassettype() const {
  return _internal_has_fundassettype();
}
inline void ContractDetails::clear_fundassettype() {
  _impl_.fundassettype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const std::string& ContractDetails::fundassettype() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.fundAssetType)
  return _internal_fundassettype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_fundassettype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000004u;
 _impl_.fundassettype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.fundAssetType)
}
inline std::string* ContractDetails::mutable_fundassettype() {
  std::string* _s = _internal_mutable_fundassettype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.fundAssetType)
  return _s;
}
inline const std::string& ContractDetails::_internal_fundassettype() const {
  return _impl_.fundassettype_.Get();
}
inline void ContractDetails::_internal_set_fundassettype(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.fundassettype_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_fundassettype() {
  _impl_._has_bits_[1] |= 0x00000004u;
  return _impl_.fundassettype_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_fundassettype() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.fundAssetType)
  if (!_internal_has_fundassettype()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000004u;
  auto* p = _impl_.fundassettype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundassettype_.IsDefault()) {
    _impl_.fundassettype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_fundassettype(std::string* fundassettype) {
  if (fundassettype != nullptr) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.fundassettype_.SetAllocated(fundassettype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fundassettype_.IsDefault()) {
    _impl_.fundassettype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.fundAssetType)
}

// optional string cusip = 44;
inline bool ContractDetails::_internal_has_cusip() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool ContractDetails::has_cusip() const {
  return _internal_has_cusip();
}
inline void ContractDetails::clear_cusip() {
  _impl_.cusip_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const std::string& ContractDetails::cusip() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.cusip)
  return _internal_cusip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_cusip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000008u;
 _impl_.cusip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.cusip)
}
inline std::string* ContractDetails::mutable_cusip() {
  std::string* _s = _internal_mutable_cusip();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.cusip)
  return _s;
}
inline const std::string& ContractDetails::_internal_cusip() const {
  return _impl_.cusip_.Get();
}
inline void ContractDetails::_internal_set_cusip(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.cusip_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_cusip() {
  _impl_._has_bits_[1] |= 0x00000008u;
  return _impl_.cusip_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_cusip() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.cusip)
  if (!_internal_has_cusip()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000008u;
  auto* p = _impl_.cusip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cusip_.IsDefault()) {
    _impl_.cusip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_cusip(std::string* cusip) {
  if (cusip != nullptr) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.cusip_.SetAllocated(cusip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cusip_.IsDefault()) {
    _impl_.cusip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.cusip)
}

// optional string issueDate = 45;
inline bool ContractDetails::_internal_has_issuedate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool ContractDetails::has_issuedate() const {
  return _internal_has_issuedate();
}
inline void ContractDetails::clear_issuedate() {
  _impl_.issuedate_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline const std::string& ContractDetails::issuedate() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.issueDate)
  return _internal_issuedate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_issuedate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000010u;
 _impl_.issuedate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.issueDate)
}
inline std::string* ContractDetails::mutable_issuedate() {
  std::string* _s = _internal_mutable_issuedate();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.issueDate)
  return _s;
}
inline const std::string& ContractDetails::_internal_issuedate() const {
  return _impl_.issuedate_.Get();
}
inline void ContractDetails::_internal_set_issuedate(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.issuedate_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_issuedate() {
  _impl_._has_bits_[1] |= 0x00000010u;
  return _impl_.issuedate_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_issuedate() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.issueDate)
  if (!_internal_has_issuedate()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000010u;
  auto* p = _impl_.issuedate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuedate_.IsDefault()) {
    _impl_.issuedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_issuedate(std::string* issuedate) {
  if (issuedate != nullptr) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  _impl_.issuedate_.SetAllocated(issuedate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuedate_.IsDefault()) {
    _impl_.issuedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.issueDate)
}

// optional string ratings = 46;
inline bool ContractDetails::_internal_has_ratings() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool ContractDetails::has_ratings() const {
  return _internal_has_ratings();
}
inline void ContractDetails::clear_ratings() {
  _impl_.ratings_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline const std::string& ContractDetails::ratings() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.ratings)
  return _internal_ratings();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_ratings(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000020u;
 _impl_.ratings_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.ratings)
}
inline std::string* ContractDetails::mutable_ratings() {
  std::string* _s = _internal_mutable_ratings();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.ratings)
  return _s;
}
inline const std::string& ContractDetails::_internal_ratings() const {
  return _impl_.ratings_.Get();
}
inline void ContractDetails::_internal_set_ratings(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.ratings_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_ratings() {
  _impl_._has_bits_[1] |= 0x00000020u;
  return _impl_.ratings_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_ratings() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.ratings)
  if (!_internal_has_ratings()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000020u;
  auto* p = _impl_.ratings_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ratings_.IsDefault()) {
    _impl_.ratings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_ratings(std::string* ratings) {
  if (ratings != nullptr) {
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  _impl_.ratings_.SetAllocated(ratings, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ratings_.IsDefault()) {
    _impl_.ratings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.ratings)
}

// optional string bondType = 47;
inline bool ContractDetails::_internal_has_bondtype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool ContractDetails::has_bondtype() const {
  return _internal_has_bondtype();
}
inline void ContractDetails::clear_bondtype() {
  _impl_.bondtype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline const std::string& ContractDetails::bondtype() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.bondType)
  return _internal_bondtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_bondtype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000040u;
 _impl_.bondtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.bondType)
}
inline std::string* ContractDetails::mutable_bondtype() {
  std::string* _s = _internal_mutable_bondtype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.bondType)
  return _s;
}
inline const std::string& ContractDetails::_internal_bondtype() const {
  return _impl_.bondtype_.Get();
}
inline void ContractDetails::_internal_set_bondtype(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.bondtype_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_bondtype() {
  _impl_._has_bits_[1] |= 0x00000040u;
  return _impl_.bondtype_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_bondtype() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.bondType)
  if (!_internal_has_bondtype()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000040u;
  auto* p = _impl_.bondtype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bondtype_.IsDefault()) {
    _impl_.bondtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_bondtype(std::string* bondtype) {
  if (bondtype != nullptr) {
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  _impl_.bondtype_.SetAllocated(bondtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bondtype_.IsDefault()) {
    _impl_.bondtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.bondType)
}

// optional double coupon = 48;
inline bool ContractDetails::_internal_has_coupon() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline bool ContractDetails::has_coupon() const {
  return _internal_has_coupon();
}
inline void ContractDetails::clear_coupon() {
  _impl_.coupon_ = 0;
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline double ContractDetails::_internal_coupon() const {
  return _impl_.coupon_;
}
inline double ContractDetails::coupon() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.coupon)
  return _internal_coupon();
}
inline void ContractDetails::_internal_set_coupon(double value) {
  _impl_._has_bits_[1] |= 0x01000000u;
  _impl_.coupon_ = value;
}
inline void ContractDetails::set_coupon(double value) {
  _internal_set_coupon(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.coupon)
}

// optional string couponType = 49;
inline bool ContractDetails::_internal_has_coupontype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool ContractDetails::has_coupontype() const {
  return _internal_has_coupontype();
}
inline void ContractDetails::clear_coupontype() {
  _impl_.coupontype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline const std::string& ContractDetails::coupontype() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.couponType)
  return _internal_coupontype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_coupontype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000080u;
 _impl_.coupontype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.couponType)
}
inline std::string* ContractDetails::mutable_coupontype() {
  std::string* _s = _internal_mutable_coupontype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.couponType)
  return _s;
}
inline const std::string& ContractDetails::_internal_coupontype() const {
  return _impl_.coupontype_.Get();
}
inline void ContractDetails::_internal_set_coupontype(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.coupontype_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_coupontype() {
  _impl_._has_bits_[1] |= 0x00000080u;
  return _impl_.coupontype_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_coupontype() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.couponType)
  if (!_internal_has_coupontype()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000080u;
  auto* p = _impl_.coupontype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coupontype_.IsDefault()) {
    _impl_.coupontype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_coupontype(std::string* coupontype) {
  if (coupontype != nullptr) {
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }
  _impl_.coupontype_.SetAllocated(coupontype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coupontype_.IsDefault()) {
    _impl_.coupontype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.couponType)
}

// optional bool convertible = 50;
inline bool ContractDetails::_internal_has_convertible() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline bool ContractDetails::has_convertible() const {
  return _internal_has_convertible();
}
inline void ContractDetails::clear_convertible() {
  _impl_.convertible_ = false;
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline bool ContractDetails::_internal_convertible() const {
  return _impl_.convertible_;
}
inline bool ContractDetails::convertible() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.convertible)
  return _internal_convertible();
}
inline void ContractDetails::_internal_set_convertible(bool value) {
  _impl_._has_bits_[1] |= 0x00800000u;
  _impl_.convertible_ = value;
}
inline void ContractDetails::set_convertible(bool value) {
  _internal_set_convertible(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.convertible)
}

// optional bool callable = 51;
inline bool ContractDetails::_internal_has_callable() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline bool ContractDetails::has_callable() const {
  return _internal_has_callable();
}
inline void ContractDetails::clear_callable() {
  _impl_.callable_ = false;
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline bool ContractDetails::_internal_callable() const {
  return _impl_.callable_;
}
inline bool ContractDetails::callable() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.callable)
  return _internal_callable();
}
inline void ContractDetails::_internal_set_callable(bool value) {
  _impl_._has_bits_[1] |= 0x02000000u;
  _impl_.callable_ = value;
}
inline void ContractDetails::set_callable(bool value) {
  _internal_set_callable(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.callable)
}

// optional bool puttable = 52;
inline bool ContractDetails::_internal_has_puttable() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool ContractDetails::has_puttable() const {
  return _internal_has_puttable();
}
inline void ContractDetails::clear_puttable() {
  _impl_.puttable_ = false;
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline bool ContractDetails::_internal_puttable() const {
  return _impl_.puttable_;
}
inline bool ContractDetails::puttable() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.puttable)
  return _internal_puttable();
}
inline void ContractDetails::_internal_set_puttable(bool value) {
  _impl_._has_bits_[1] |= 0x04000000u;
  _impl_.puttable_ = value;
}
inline void ContractDetails::set_puttable(bool value) {
  _internal_set_puttable(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.puttable)
}

// optional string descAppend = 53;
inline bool ContractDetails::_internal_has_descappend() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool ContractDetails::has_descappend() const {
  return _internal_has_descappend();
}
inline void ContractDetails::clear_descappend() {
  _impl_.descappend_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline const std::string& ContractDetails::descappend() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.descAppend)
  return _internal_descappend();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_descappend(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000100u;
 _impl_.descappend_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.descAppend)
}
inline std::string* ContractDetails::mutable_descappend() {
  std::string* _s = _internal_mutable_descappend();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.descAppend)
  return _s;
}
inline const std::string& ContractDetails::_internal_descappend() const {
  return _impl_.descappend_.Get();
}
inline void ContractDetails::_internal_set_descappend(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.descappend_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_descappend() {
  _impl_._has_bits_[1] |= 0x00000100u;
  return _impl_.descappend_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_descappend() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.descAppend)
  if (!_internal_has_descappend()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000100u;
  auto* p = _impl_.descappend_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descappend_.IsDefault()) {
    _impl_.descappend_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_descappend(std::string* descappend) {
  if (descappend != nullptr) {
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }
  _impl_.descappend_.SetAllocated(descappend, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descappend_.IsDefault()) {
    _impl_.descappend_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.descAppend)
}

// optional string nextOptionDate = 54;
inline bool ContractDetails::_internal_has_nextoptiondate() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool ContractDetails::has_nextoptiondate() const {
  return _internal_has_nextoptiondate();
}
inline void ContractDetails::clear_nextoptiondate() {
  _impl_.nextoptiondate_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline const std::string& ContractDetails::nextoptiondate() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.nextOptionDate)
  return _internal_nextoptiondate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_nextoptiondate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000200u;
 _impl_.nextoptiondate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.nextOptionDate)
}
inline std::string* ContractDetails::mutable_nextoptiondate() {
  std::string* _s = _internal_mutable_nextoptiondate();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.nextOptionDate)
  return _s;
}
inline const std::string& ContractDetails::_internal_nextoptiondate() const {
  return _impl_.nextoptiondate_.Get();
}
inline void ContractDetails::_internal_set_nextoptiondate(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.nextoptiondate_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_nextoptiondate() {
  _impl_._has_bits_[1] |= 0x00000200u;
  return _impl_.nextoptiondate_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_nextoptiondate() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.nextOptionDate)
  if (!_internal_has_nextoptiondate()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000200u;
  auto* p = _impl_.nextoptiondate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextoptiondate_.IsDefault()) {
    _impl_.nextoptiondate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_nextoptiondate(std::string* nextoptiondate) {
  if (nextoptiondate != nullptr) {
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }
  _impl_.nextoptiondate_.SetAllocated(nextoptiondate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextoptiondate_.IsDefault()) {
    _impl_.nextoptiondate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.nextOptionDate)
}

// optional string nextOptionType = 55;
inline bool ContractDetails::_internal_has_nextoptiontype() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool ContractDetails::has_nextoptiontype() const {
  return _internal_has_nextoptiontype();
}
inline void ContractDetails::clear_nextoptiontype() {
  _impl_.nextoptiontype_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline const std::string& ContractDetails::nextoptiontype() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.nextOptionType)
  return _internal_nextoptiontype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_nextoptiontype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000400u;
 _impl_.nextoptiontype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.nextOptionType)
}
inline std::string* ContractDetails::mutable_nextoptiontype() {
  std::string* _s = _internal_mutable_nextoptiontype();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.nextOptionType)
  return _s;
}
inline const std::string& ContractDetails::_internal_nextoptiontype() const {
  return _impl_.nextoptiontype_.Get();
}
inline void ContractDetails::_internal_set_nextoptiontype(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.nextoptiontype_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_nextoptiontype() {
  _impl_._has_bits_[1] |= 0x00000400u;
  return _impl_.nextoptiontype_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_nextoptiontype() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.nextOptionType)
  if (!_internal_has_nextoptiontype()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000400u;
  auto* p = _impl_.nextoptiontype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextoptiontype_.IsDefault()) {
    _impl_.nextoptiontype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_nextoptiontype(std::string* nextoptiontype) {
  if (nextoptiontype != nullptr) {
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }
  _impl_.nextoptiontype_.SetAllocated(nextoptiontype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextoptiontype_.IsDefault()) {
    _impl_.nextoptiontype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.nextOptionType)
}

// optional bool nextOptionPartial = 56;
inline bool ContractDetails::_internal_has_nextoptionpartial() const {
  bool value = (_impl_._has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline bool ContractDetails::has_nextoptionpartial() const {
  return _internal_has_nextoptionpartial();
}
inline void ContractDetails::clear_nextoptionpartial() {
  _impl_.nextoptionpartial_ = false;
  _impl_._has_bits_[1] &= ~0x08000000u;
}
inline bool ContractDetails::_internal_nextoptionpartial() const {
  return _impl_.nextoptionpartial_;
}
inline bool ContractDetails::nextoptionpartial() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.nextOptionPartial)
  return _internal_nextoptionpartial();
}
inline void ContractDetails::_internal_set_nextoptionpartial(bool value) {
  _impl_._has_bits_[1] |= 0x08000000u;
  _impl_.nextoptionpartial_ = value;
}
inline void ContractDetails::set_nextoptionpartial(bool value) {
  _internal_set_nextoptionpartial(value);
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.nextOptionPartial)
}

// optional string bondNotes = 57;
inline bool ContractDetails::_internal_has_bondnotes() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool ContractDetails::has_bondnotes() const {
  return _internal_has_bondnotes();
}
inline void ContractDetails::clear_bondnotes() {
  _impl_.bondnotes_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline const std::string& ContractDetails::bondnotes() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.bondNotes)
  return _internal_bondnotes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_bondnotes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000800u;
 _impl_.bondnotes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.bondNotes)
}
inline std::string* ContractDetails::mutable_bondnotes() {
  std::string* _s = _internal_mutable_bondnotes();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.bondNotes)
  return _s;
}
inline const std::string& ContractDetails::_internal_bondnotes() const {
  return _impl_.bondnotes_.Get();
}
inline void ContractDetails::_internal_set_bondnotes(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.bondnotes_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_bondnotes() {
  _impl_._has_bits_[1] |= 0x00000800u;
  return _impl_.bondnotes_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_bondnotes() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.bondNotes)
  if (!_internal_has_bondnotes()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000800u;
  auto* p = _impl_.bondnotes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bondnotes_.IsDefault()) {
    _impl_.bondnotes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_bondnotes(std::string* bondnotes) {
  if (bondnotes != nullptr) {
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }
  _impl_.bondnotes_.SetAllocated(bondnotes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bondnotes_.IsDefault()) {
    _impl_.bondnotes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.bondNotes)
}

// repeated .protobuf.IneligibilityReason ineligibilityReasonList = 58;
inline int ContractDetails::_internal_ineligibilityreasonlist_size() const {
  return _impl_.ineligibilityreasonlist_.size();
}
inline int ContractDetails::ineligibilityreasonlist_size() const {
  return _internal_ineligibilityreasonlist_size();
}
inline ::protobuf::IneligibilityReason* ContractDetails::mutable_ineligibilityreasonlist(int index) {
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.ineligibilityReasonList)
  return _impl_.ineligibilityreasonlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::IneligibilityReason >*
ContractDetails::mutable_ineligibilityreasonlist() {
  // @@protoc_insertion_point(field_mutable_list:protobuf.ContractDetails.ineligibilityReasonList)
  return &_impl_.ineligibilityreasonlist_;
}
inline const ::protobuf::IneligibilityReason& ContractDetails::_internal_ineligibilityreasonlist(int index) const {
  return _impl_.ineligibilityreasonlist_.Get(index);
}
inline const ::protobuf::IneligibilityReason& ContractDetails::ineligibilityreasonlist(int index) const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.ineligibilityReasonList)
  return _internal_ineligibilityreasonlist(index);
}
inline ::protobuf::IneligibilityReason* ContractDetails::_internal_add_ineligibilityreasonlist() {
  return _impl_.ineligibilityreasonlist_.Add();
}
inline ::protobuf::IneligibilityReason* ContractDetails::add_ineligibilityreasonlist() {
  ::protobuf::IneligibilityReason* _add = _internal_add_ineligibilityreasonlist();
  // @@protoc_insertion_point(field_add:protobuf.ContractDetails.ineligibilityReasonList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuf::IneligibilityReason >&
ContractDetails::ineligibilityreasonlist() const {
  // @@protoc_insertion_point(field_list:protobuf.ContractDetails.ineligibilityReasonList)
  return _impl_.ineligibilityreasonlist_;
}

// optional string eventContract1 = 59;
inline bool ContractDetails::_internal_has_eventcontract1() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool ContractDetails::has_eventcontract1() const {
  return _internal_has_eventcontract1();
}
inline void ContractDetails::clear_eventcontract1() {
  _impl_.eventcontract1_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline const std::string& ContractDetails::eventcontract1() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.eventContract1)
  return _internal_eventcontract1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_eventcontract1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00001000u;
 _impl_.eventcontract1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.eventContract1)
}
inline std::string* ContractDetails::mutable_eventcontract1() {
  std::string* _s = _internal_mutable_eventcontract1();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.eventContract1)
  return _s;
}
inline const std::string& ContractDetails::_internal_eventcontract1() const {
  return _impl_.eventcontract1_.Get();
}
inline void ContractDetails::_internal_set_eventcontract1(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.eventcontract1_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_eventcontract1() {
  _impl_._has_bits_[1] |= 0x00001000u;
  return _impl_.eventcontract1_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_eventcontract1() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.eventContract1)
  if (!_internal_has_eventcontract1()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00001000u;
  auto* p = _impl_.eventcontract1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventcontract1_.IsDefault()) {
    _impl_.eventcontract1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_eventcontract1(std::string* eventcontract1) {
  if (eventcontract1 != nullptr) {
    _impl_._has_bits_[1] |= 0x00001000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00001000u;
  }
  _impl_.eventcontract1_.SetAllocated(eventcontract1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventcontract1_.IsDefault()) {
    _impl_.eventcontract1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.eventContract1)
}

// optional string eventContractDescription1 = 60;
inline bool ContractDetails::_internal_has_eventcontractdescription1() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool ContractDetails::has_eventcontractdescription1() const {
  return _internal_has_eventcontractdescription1();
}
inline void ContractDetails::clear_eventcontractdescription1() {
  _impl_.eventcontractdescription1_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline const std::string& ContractDetails::eventcontractdescription1() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.eventContractDescription1)
  return _internal_eventcontractdescription1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_eventcontractdescription1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00002000u;
 _impl_.eventcontractdescription1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.eventContractDescription1)
}
inline std::string* ContractDetails::mutable_eventcontractdescription1() {
  std::string* _s = _internal_mutable_eventcontractdescription1();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.eventContractDescription1)
  return _s;
}
inline const std::string& ContractDetails::_internal_eventcontractdescription1() const {
  return _impl_.eventcontractdescription1_.Get();
}
inline void ContractDetails::_internal_set_eventcontractdescription1(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.eventcontractdescription1_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_eventcontractdescription1() {
  _impl_._has_bits_[1] |= 0x00002000u;
  return _impl_.eventcontractdescription1_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_eventcontractdescription1() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.eventContractDescription1)
  if (!_internal_has_eventcontractdescription1()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00002000u;
  auto* p = _impl_.eventcontractdescription1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventcontractdescription1_.IsDefault()) {
    _impl_.eventcontractdescription1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_eventcontractdescription1(std::string* eventcontractdescription1) {
  if (eventcontractdescription1 != nullptr) {
    _impl_._has_bits_[1] |= 0x00002000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00002000u;
  }
  _impl_.eventcontractdescription1_.SetAllocated(eventcontractdescription1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventcontractdescription1_.IsDefault()) {
    _impl_.eventcontractdescription1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.eventContractDescription1)
}

// optional string eventContractDescription2 = 61;
inline bool ContractDetails::_internal_has_eventcontractdescription2() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool ContractDetails::has_eventcontractdescription2() const {
  return _internal_has_eventcontractdescription2();
}
inline void ContractDetails::clear_eventcontractdescription2() {
  _impl_.eventcontractdescription2_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline const std::string& ContractDetails::eventcontractdescription2() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.eventContractDescription2)
  return _internal_eventcontractdescription2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_eventcontractdescription2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00004000u;
 _impl_.eventcontractdescription2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.eventContractDescription2)
}
inline std::string* ContractDetails::mutable_eventcontractdescription2() {
  std::string* _s = _internal_mutable_eventcontractdescription2();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.eventContractDescription2)
  return _s;
}
inline const std::string& ContractDetails::_internal_eventcontractdescription2() const {
  return _impl_.eventcontractdescription2_.Get();
}
inline void ContractDetails::_internal_set_eventcontractdescription2(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.eventcontractdescription2_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_eventcontractdescription2() {
  _impl_._has_bits_[1] |= 0x00004000u;
  return _impl_.eventcontractdescription2_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_eventcontractdescription2() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.eventContractDescription2)
  if (!_internal_has_eventcontractdescription2()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00004000u;
  auto* p = _impl_.eventcontractdescription2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventcontractdescription2_.IsDefault()) {
    _impl_.eventcontractdescription2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_eventcontractdescription2(std::string* eventcontractdescription2) {
  if (eventcontractdescription2 != nullptr) {
    _impl_._has_bits_[1] |= 0x00004000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00004000u;
  }
  _impl_.eventcontractdescription2_.SetAllocated(eventcontractdescription2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventcontractdescription2_.IsDefault()) {
    _impl_.eventcontractdescription2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.eventContractDescription2)
}

// optional string minAlgoSize = 62;
inline bool ContractDetails::_internal_has_minalgosize() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool ContractDetails::has_minalgosize() const {
  return _internal_has_minalgosize();
}
inline void ContractDetails::clear_minalgosize() {
  _impl_.minalgosize_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline const std::string& ContractDetails::minalgosize() const {
  // @@protoc_insertion_point(field_get:protobuf.ContractDetails.minAlgoSize)
  return _internal_minalgosize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractDetails::set_minalgosize(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00008000u;
 _impl_.minalgosize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuf.ContractDetails.minAlgoSize)
}
inline std::string* ContractDetails::mutable_minalgosize() {
  std::string* _s = _internal_mutable_minalgosize();
  // @@protoc_insertion_point(field_mutable:protobuf.ContractDetails.minAlgoSize)
  return _s;
}
inline const std::string& ContractDetails::_internal_minalgosize() const {
  return _impl_.minalgosize_.Get();
}
inline void ContractDetails::_internal_set_minalgosize(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00008000u;
  _impl_.minalgosize_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractDetails::_internal_mutable_minalgosize() {
  _impl_._has_bits_[1] |= 0x00008000u;
  return _impl_.minalgosize_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractDetails::release_minalgosize() {
  // @@protoc_insertion_point(field_release:protobuf.ContractDetails.minAlgoSize)
  if (!_internal_has_minalgosize()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00008000u;
  auto* p = _impl_.minalgosize_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.minalgosize_.IsDefault()) {
    _impl_.minalgosize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractDetails::set_allocated_minalgosize(std::string* minalgosize) {
  if (minalgosize != nullptr) {
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }
  _impl_.minalgosize_.SetAllocated(minalgosize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.minalgosize_.IsDefault()) {
    _impl_.minalgosize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuf.ContractDetails.minAlgoSize)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ContractDetails_2eproto
